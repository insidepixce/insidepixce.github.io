---
pin: true
layout: post
title: "20240129 TIL"
categories:
  - TIL
tags:
  - 패스파인더
author: insidepixce
show_excerpts: true
date: 2024-01-29 00:30:00 +0900
disqus: true
paginate: true
disqus-count-scr: true
comments: true
toc: true
---

#오늘의 다짐

오늘부터는 최대한 많은 것들을 아껴보려 한다.

자꾸만 새어나가는 시간들을 좀 더 철저하게 관리해야 할 것 같아. 점심떄 잠이 오는게 당연하다. 엄청엄청 늦게 자기 때문이다 . 그럼에도 불구하고 시간을 아끼지 않는다. 아침에 일어나서 열심히 일하고 공부한 후에 저녁에는 바로바로 자면 해결될 문제인데 왜 이렇게 시간을 펑펑 쓰는지 나도 내가 이해가 되지 않는다.

이 시간대에 공부하거나 숙제하는 초등학생 아이들도 많은데 지금 내가 잠온다고 하면 안 되는거지 


# 실행 컨텍스트
- 자바스크립트의 동작 원리를 담고 있는 핵심 개념
- 자바스크립트가 스코프를 기반으로 식별자와 식별자에 바인딩 된 값 (식별자 바인딩) 을 관리하는 방식
- 호이스팅이 발생하는 이유
- 클로저의 동작 방식
- 태스크 큐와 함께 동작하는 이벤트들이 동작하는 이벤트 핸들러와 비동기 처리의 동작 방식을 이용할 수 있음

책의 목차에 들어가기에 앞서 구글링을 해보았다 

# 실행 컨텍스트 - 구글링 추합 버전

먼저 이걸 이해하기 전에 여러 사항들을 알아야 하는데...

## 1. 변수 호이스팅 - 
 자바스크립트에서 코드가 실행되기 전에 변수 선언이 미리 올려지는 현상이 있다. 
 
 -> 실행 컨텍스트는 변수 호이스팅을 통해 변수를 미리 메모리에 등록한다

 * 선언 단계 
 
 ->변수 및 함수 선언이 미리 메모리에 등록된다. 이때 변수는 UNDEFINED로 초기화되고, 함수는 전체함수 코드가 메모리에 저장된다 
  * 실행 단계 

  -> 코드가 실제로 실행되며 변수에 값이 할당되고 함수가 호출된다 
  ```
  console.log(x); // undefined
var x = 5;
console.log(x); // 5

  ```

이 코드에서 'console.log(x);' 를 실행하기 전에 var x; 가 먼저 처리되어 변수 x가 선언되고 undefined로 초기화 된다. 그 후에 코드가 순차적으로 실행되면서 두 번쨰 console.log("Hello World!") 에서는 5가 출력된다 .

함수 선언도 비슷한 방식으로 호이스팅되었다. 함수 선언문은 함수 전체가 끌어올려지기 때문에 함수를 선언하기 전에 호출할 수 있다 


  ```
hello(); // "Hello, World!"

function hello() {
  console.log("Hello, World!");
}

  ```
하지만 변수 선언과 함수 선언은 호이스팅이 되지만, 변수 할당문과 함수 표현식은 호이스팅이 되지 않는다. 이러한 동작은 코드를 작성할 떄 주의를 기울여야 하는 부분 중 하나이다. 


 ##  2. 스코프 체인  
 스코프는 변수에 접근할 수 있는 범위를 나타낸다. 함수가 중첩되어 있는 경우, 내부 함수는 외부 함수의 스코프에 스코프에 접근할 수 있다. 이때 스코프 체인은 변수를 찾을 때, 현재 스코프에부터 차례로 외부 스코프로 이동하면서 검색하는 매카니즘을 말한다 

 ##  3. THIS 키워드 
 실행 컨텍스트는 THIS 키워드를 통해 현재 실행중인 함수가 속한 객체를 참조한다.
 
 ## 4. 클로저 
 함수가 다른 함수의 스코프에 접근할 수 있는 현상을 말한다. 실행 컨텍스트는 클로저를 생성하고 함수가 정의된 스코프의 변수에 접근할 수 있도록 한다 

 ## 5. 데이터 환경 
  실행 컨텍스트는 현재 실행 중인 코드의 변수, 함수 선언 등과 같은 정보를 담고 있는데, 이를 데이터 환경이라고 부른다

 이러한 요소들이 모여 실행 컨텍스트를 생성한다. 함수가 호출될 때마다 새로운 실행 컨텍스트가 만들어지고 , 함수의 실행이 끝나면 해당 컨텍스트는 파기된다. 이를 통해 자바스크립트 엔진은 변수의 유효 범위, 값의 할당 및 참고, 함수의 호출 등을 관리한다. 

 > 그럼 이제 책을 볼까 ? 

 # 소스코드의 타입
 ECMAScript 사양에서는 소스 코드를 4가지 타입으로 구분하고 각각의 타입이 실행 컨텍스트를 생성한다고 설명한다.  각 소스 코드 타입과 관련된 용어들을 자세히 설명하고, 각각의 예시도 제시해보겠다.

### 1. 전역 코드 (Global Code):
   - **설명:** 전역에 존재하는 소스 코드를 말한다.  전역에서 정의된 함수, 클래스 등의 내부 코드는 이에 포함되지 않음.
   - **예시:**
     ```javascript
     const globalVar = 10;

     function globalFunction() {
       console.log("Global Function");
     }
     ```
전역 코드는 전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성해야 한다. 그리고 var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역 객체가 연결되어야 한다. 이를 위해 전역 코드가 평가되면 전역 실행 컨텍스트가 생성된다ㅓ 

### 2. 함수 코드 (Function Code):
   - **설명:** 함수 내부에 존재하는 소스 코드를 말한다. 
    함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 여기에 속하지 않는다
   - **예시:**
     ```javascript
     function outerFunction() {
       const outerVar = 20;

       function innerFunction() {
         console.log("Inner Function");
       }
     }
     ```
함수 코드는 지역 스코프를 생성하고 지역 변수, 매개변수, arguments 객체를 관리해야 한다. 그리고 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결해야 한다. 이를 위해 함수 코드가 평가되면 함수 실행 컨텍스트가 생성된다 


### 3. eval 코드 (Eval Code):
   - **설명:** 빌트인 전역 함수인 `eval` 함수에 인수로 전달되어 실행되는 소스 코드를 의미한다.
   - **예시:**
     ```javascript
     const evalCode = 'console.log("Eval Code")';
     eval(evalCode);

     ```
eval 코드는 strict mode (엄격 모드) 에서 자신만의 독자적인 스코프를 생성한다. 이를 위해 eval 코드가 평가되면 eval 실행 컨텍스트가 생성된다 

### 4. 모듈 코드 (Module Code):
   - **설명:** 모듈 내부에 존재하는 소스 코드를 말한다. 모듈 내부의 함수, 클래스 등의 내부 코드는 여기에 속하지 않누.
   - **예시:**
     ```javascript
     // 파일: myModule.js
     const moduleVar = 30;

     export function moduleFunction() {
       console.log("Module Function");
     }
     ```

모듈 코드는 모듈별로 독립적인 모듈 스코프를 생성한다. 이를 위해 모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성된다 


### 용어 설명:

- **전역 (Global):** 코드나 변수 등이 어디에서나 접근 가능한 범위를 의미한다. 전역에서 선언된 것들은 프로그램 전체에서 사용 가능하다.
- **빌트인 (Built-in):** 언어 자체에 내장된 함수나 객체를 의미한다. JavaScript에는 빌트인 함수들이 내장되어 있어, 예를 들어 `eval` 함수가 그 중 하나이다 .
- **eval:** 문자열을 JavaScript 코드로 변환하여 실행하는 함수이다. 주로 동적으로 코드를 실행해야 할 때 사용되지만, 남용되면 코드를 이해하기 어려워질 수 있다.
- **인수 (Argument):** 함수에 전달되는 값 또는 표현식을 의미한다. `eval` 함수의 인수로 전달되는 것은 실행될 소스 코드이다.



## 소스코드의 평가와 실행

모든 소스코드는 코드를 실행하기 위한 준비를 한다. 
자바스크립트 엔진은 소스코드를 2개의 과정, 즉 "소스코드의 평가" 와 "소스코드의 실행" 과정으로 나누어 처리함

### 1. 소스코드 평가 과정 

1.1 실행 컨텍스트 생성

실행 컨텍스트는 코드가 실행되는 환경을 추상화한 개념이다. 각 함수 실행이나 전역 실행에 대한 정보를 담고 있다 
실행 컨텍스트는 전역 컨텍스트와 함수 컨텍스트로 나누어진다 

1.2변수 및 함수 선언문 실행

변수. 함수 등의 선언문만 먼저 실행하여 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프에 등록한다. 변수와 함수 식별자는 스코프(유효 범위)에 등록되고, 해당 스코프에서 식별자에 대한 참조를 할 수 있게 된다 

1.3 소스코드 평가 완료

변수 및 함수 선언문의 실행이 완료되면 소스코드 평가가 완료된다. 이 단계에서는 선언문을 제외한 나머지 코드는 아직 실행되지 않은 채로 대기하고 있다. 

### 2. 소스코드 실행 과정

2.1 런타임 시작 

소스코드 평가가 완료되면 실제로 코드가 순차적으로 실행되기 시작한다. 이를 런타임이 시작된다고 한다. 

2.2 순차적인 코드 실행

소스코드 실행 과정에서는 변수에 값이 할당되거나 함수가 호출되는 등의 동작이 이루어진다. 이때 변수에 값이 할당되는 경우. 해당 변수의 스코프에서 식별자를 찾아 실제 값을 할당하게 된다 . 

이렇게 소스코드 평가와 실행이 나누어져 있기 때문에 함수 선언문이 소스코드 상단에 있더라도 실행 컨텍스트 생성 시에 먼저 등록되므로 함수를 호출하기 전에도 함수에 접근할 수 있게 된다. 이러한 동작은 호이스팅이라고 불리며, 자바스크립트 엔진이 소스코드를 평가하는 동안 발생한다 

> 변수가 선언된 변수인지 확인해야 한다. 만약 X 변수가 선언된 변수라면 값을 할당하고 할당 결과를 실행 컨텍스트에 등록하여 리한다 

## 실행 컨텍스트의 역할

### 1. 전역 코드 평가 
전역 코드를 실행하기에 앞서 먼저 전역 코드 평가 과정을 거치며 전역 코드를 실행하기 위한 준비를 한다. 소스코드 평가 과정에서는 선언문만 먼저 실행한다. 따라서 전역 코드의 변수 선언문과 함수 선언문이 먼저 실행되고, 그 결과 생성된 전역 변수와 전역 함수가 실행 컨텍스트가 관리하는 전경 스코프에 등록된다. 이때 VAR 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티와 메서드가 된다 


### 2. 전역 코드 실행
전역 코드 평가 과정이 끝나면 '런타임'이 시작되어 전역코드가 순차적으로 실행되기 시작한다. 이때 전역 변수에 값이 할당되고 함수가 호출된다. 함수가 호출되면 순차적으로 실행되던 전역 코드의 실행을 일시 중단하고 코드 실행 순서를 변경하여 함수 내부로 진입한다 

### 3. 함수 코드 평가 
함수 호출에 의해 코드 실행 순서가 변경되어 함수 내부로 진입하면 함수 내부의 문들을 실행하기에 앞서 함수 코드 평가 과정을 거치며 함수 코드를 실행하기 위한 준비를 한다. 이때 매개변수와 지역 변수 선언문이 먼저 실행되고, 그 결과 생성된 매개변수와 지역 변수가 실행 컨텍스트가 관리하는 지역 스코프에 등록된다. 또한 함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체가 생성되어 지역 스코프에 등록되고 this 바인딩도 결정된다 


### 4. 함수 코드 실행
함수 코드 평가 과정이 끝나면 런타임이 시작되어 함수 코드가 순차적으로 실행되기 시작한다. 이떄 매개변수와 지역 변수에 값이 할당되고 console.log 메서드가 호출된다

console.log 메서드를 호출하기 위해 먼저 식별자인 console을 스코프 체인을 통해 검색한다. 이를 위해 함수 코드의 지역 변수에 값이 할당되고 console.log 메서드가 호출된다

console.log 메서드를 호출하기 위해 먼저 식별자인 console을 스코프 체인을 통해 검색한다. 이를 위해 함수 코드의 지역 스코프는 상위 스코프인 전역 스코프와 연결되어야 한다. 하지만 console 식별자는 스코프 체인에 등록 되어 있지 않고 전역 객체에 프로퍼티로 존재한다. 이는 전역 객체의 프로퍼티가 마치 전역 변수처럼 전역 스코프를 통해 검색 가능해야 한다는 것을 의미한다 

이처럼 코드가 실행되려면 스코프를 구분하여 식별자와 바인딩된 값이 관리되어야 한다. 그리고 중첩 관계에 의해 스코프 체인을 형성하여 식별자를 검색할 수 있어야 하고, 전역 객체의 프로퍼티도 전역 변수처럼 검색할 수 있어야 한다 . 

#정리 

1. 전역 코드 평가 

전역 코드 실행을 위한 준비로, 전역 변수 및 함수 선언문을 먼저 실행하여 전역 스코프에 등록하다 
var로 선언된 전역 변수와 함수 선언문은 전역 객체의 프로퍼티와 메서드가 된다 

2. 전역 코드 실행

전역 코드 평가가 끝나면 런타임이 시작되어 전역 코드가 순차적으로 실행된다 
전역 변수에 값이 할당되고 함수가 호출될 때 코드 실행 순서가 변경되어 함수 내부로 진입한다 

3. 함수 코드 평가 

함수 호출에 따라 함수 내부로 진입하기 전, 함수 코드 실행을 위한 준비를 위해 매개변수 및 지역 변수 선언문을 실행한다

결과로 생성된 매개변수와 지역 변수는 지역 스코프에 등록되며, arguments 객체와  this 바인딩도 결정된다 

4. 함수 코드 실행

함수 코드 평가가 끝나면 런타임이 시작되어 함수 코드가 순차적으로 실행된다. 변수에 값이 할당되고 console.log 메서드가 호출될때 식별자인 console을 스코프 체인을 통해 검색한다 


추가 설명
- 스코프는 중첩 관계에 따라 스코프 체인을 형성하며 식별자와 바인딩된 값이 관리된다 

-> 각가의 스코프는 자신이 감싸고 있는 스코프를 참조할 수 있다. 이로 인해 변수나 함수 등의 식별자를 검색할 때 현재 스코프에서 찾지 못하면 상위 스코프로 이동하여 검색하는 방식을 취하게 된다. 이러한 구조를 통해 스코프 체인이 형성되어 식별자의 유효 범위가 결정된다 
```
function outerFunc() {
  var outerVar = 10;

  function innerFunc() {
    var innerVar = 20;
    console.log(outerVar + innerVar);
  }

  innerFunc();
}

outerFunc();

```

이 같은 코드는 innerFunc 함수가 outerFunc 함수에 중첩되어 있다. 이 경우 innerFunc 내부에서 outerVar를 참조할 수 있다. 스코프 체인을 통해 찾지 못하면 상위 스코프인 outerFunc의 스코프로 이동하여 해당 변수를 찾는다. 이러한 중첩된 구조를 통해 스코프 체인이 형성되고 변수들이 관리된다 


- 전역 객체의 프로퍼티는 전역 변수처럼 검색 가능하며 이는 스코프 체인이 전역 스코프를 통해 전역 객체에 접근할 수 있게 해준다 

자바스크립트에서 전역 객체는 모든 전역 변수와 함수의 최상위 객체이다. 브라우저 환경에서는 전역 객체를 window라고 부르며, node js 환경에서는 global 객체입니다. 전역 변수나 함수는 사실상 이 전역 객체의 프로퍼티로 존재하게 된다.

스코프 체인은 변수나 함수를 찾을 때 현재 스코프에서 찾지 못하면 상위 스코프로 올라가며 검색한다고 아까도 언급했는데, 이 과정에서 전역 스코프까지 ㅎ올라가면 전역 객체를 만날 수 있다. 따라서 전역 변수나 함수는 전역 객체의 프로퍼티로 간주되며, 스코프 체인을 통해 검색 가능한 것이다

```
var globalVar = "I am global!";

function printGlobalVar() {
  console.log(globalVar);
}

printGlobalVar();
```
이 코드에서 prinGlobalVar함수는 전역 변수인 globalVar를 사용한다. 함수 내에서 globalVar를 찾을 때 스코프 체인을 통해 전역 스코프로 올라가고 전역 스코프에서는 이 변수가 전역 객체의 프로퍼티로 등록되어있기 때문에 찾을수가 없다 


