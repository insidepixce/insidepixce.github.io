<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-01-11T10:51:10+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">InandOutsidepixce</title><subtitle>살아가는 방법을 다룹니다</subtitle><author><name>insidepixce</name></author><entry><title type="html">암호화 키 오류</title><link href="http://localhost:4000/conflict/2024/01/10/itsone.html" rel="alternate" type="text/html" title="암호화 키 오류" /><published>2024-01-10T21:00:00+09:00</published><updated>2024-01-10T21:00:00+09:00</updated><id>http://localhost:4000/conflict/2024/01/10/itsone</id><content type="html" xml:base="http://localhost:4000/conflict/2024/01/10/itsone.html"><![CDATA[<p>아침부터 에러나는건 우리 예의가 아니지 </p>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/7kap/image/X7sAg-E45Tgfn5DhO46R2O1wN3Q.jpg" alt="예시 이미지" /></p>

<p>리엑트 네이티브로 개발하는 앱에서 결제 기능을 추가하는 것은 꽤나 일반적인 작업 중 하나인데 오늘 진짜 특이한 경험을 했다.</p>

<p>하지마 이 개새끼야 ~!!!!!</p>

<h2 id="1-문제-발견">1. 문제 발견</h2>

<p>결제 프로세스를 시작하자 마자 “암호화 키가 일치하지 않는다”라는 에러가 발생했다. 테스트해보니 사용자에게도 노출될 코드였다.</p>

<h2 id="2-초기분석">2. 초기분석</h2>

<p>처음에는서버측에서 보내는 암호화 키와 클라이언트에서사용하는 암호화 키가 다르다고 생각했다. 서버 코드를 열고 관련 키 값들을 점검했다. 근데,,, 어,,, 둘다 암호화 키가 같다…?</p>

<h2 id="3-디버깅-시작">3. 디버깅 시작</h2>

<p>결제과정 코드를 꼼꼼히 살펴보았다. 하는 도중에 내가 이래서 js를 좋아한다는 걸 깨달았다. 읽기가 너무 편해</p>

<p>아무튼 암호화 모듈을 살펴보았는데, 네이티브 모듈로 구현되어있었다. js코드와 네이티브 코드간의 통신이 피요했다</p>

<h2 id="4-문제의-원인을-봤다">4. 문제의 원인을 봤다.</h2>

<p>암호화를 담당하는 부분의 로직을 보고 보고 보고 또 봤다. 아니 세상에. 암호화 키를 생성하고 저장하는 로직에 큰 문제점이 있었다. 암호화 키는 앱이 설치될때마다 생성되어야 하는데 이 키가 여러번 생성되어서 중복되는 문제가 있었다. 서버에서는 암호화된 데이터를 복호화할수 없었고, 이러한 문제가 생겨버린 것이다.</p>

<p>실제 코드는 아니지만 재현해보자면 이런 구조였다</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { NativeModules } from 'react-native';

const { EncryptionModule } = NativeModules;

class PaymentService {
  constructor() {
    this.encryptionKey = this.generateEncryptionKey();
  }

  generateEncryptionKey() {
    return EncryptionModule.generateKey();
  }

  makePayment(data) {
    const encryptedData = EncryptionModule.encrypt(data, this.encryptionKey);
    // ... 결제 로직
  }
}
</code></pre></div></div>

<p>‘PaymentService’클래스가 생성될때마다 ‘generateEncryptionKey’함수가 호출되어 암호화 키가 생성된다. 다른 모듈이나 컴포넌트에서 ‘PaymentService’를 여러번 초기화할 경우, 다양한 키 값들이 생성되었고, 그게 문제였던 것이다 !</p>

<p>ㅇ아ㅏ… 이마 한 번 짚고 다시 달린다.</p>

<ol>
  <li>키 생성 로직 개선 : 암호화 키 생성 로직을 수정해 키가 한번만 생성되도록 만든다</li>
  <li>데이터베이스 키 저장 : 생성된 키를 로컬 데이터베이스에 저장하고 앱이 실행될때마다 해당 키를 불러와 사용하도록 로직을 바꿨다.</li>
  <li>키 동기화 : 서버와의 통신 시 생성된 키를 함께 전송하여 서버도 동일한 키를 사용하도록 했다.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { NativeModules } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';

const { EncryptionModule } = NativeModules;

class PaymentService {
  constructor() {
    this.loadEncryptionKey();
  }

  async loadEncryptionKey() {
    let key = await AsyncStorage.getItem('encryptionKey');
    if (!key) {
      key = EncryptionModule.generateKey();
      await AsyncStorage.setItem('encryptionKey', key);
    }
    this.encryptionKey = key;
  }

  makePayment(data) {
    const encryptedData = EncryptionModule.encrypt(data, this.encryptionKey);
    // ... 결제 로직
  }
}
</code></pre></div></div>

<p>대충 이런 구조로 수정해주었다</p>

<ul>
  <li>Singleton Pattern : ‘PaymentService’를 싱글톤 패턴으로 구현하여 인스턴스가 하나만 생성되도록하였다. 이렇게 하면 암호화 키도 한 번만 생성된다</li>
  <li>AsyncStorage : 생성된 암호화 키를 로컬에 저장하여 앱이 재시작될때마다 동일한 키를 사용하도록 했다. 이를 위해 @react-native-async-storage/async-storage 라이브러리를 사용했다</li>
  <li>초기화 로직 변경 : ‘PaymentService’의 초기화 로직에서 암호화 키를 생성하는 대신, 로컬 데이터베이스에서 불러와 사용하도록 변경해주었다. 키가 없을 경우에만 새로 생성했다.</li>
  <li>아마도 로컬로 저장하는것도 방법인 것 같다. 생성된 암호화 키는 로컬 데이터베이스, 예를 들면 AsyncStorage</li>
</ul>

<p>암호화는 데이터 보호를 위해 꼭 필요한 과정이다. 특히 결제나 인증과 같은 중요한 트랜젝션에서는 데이터의 무결성을 보장하기 위해 암호화가 필수이다. 리엑트 네이티브에서도 이러한 암호하 처리가 필요하고, 암호화 키를 안전하게 관리하는 것 또한 중요한데,  진짜 나 정신차리자 .</p>]]></content><author><name>insidepixce</name></author><category term="conflict" /><category term="react" /><summary type="html"><![CDATA[아침부터 에러나는건 우리 예의가 아니지 ]]></summary></entry><entry><title type="html">동기비동기 한판정리</title><link href="http://localhost:4000/%ED%8C%A8%EC%8A%A4%ED%8C%8C%EC%9D%B8%EB%8D%94/conflict/2024/01/10/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0.html" rel="alternate" type="text/html" title="동기비동기 한판정리" /><published>2024-01-10T21:00:00+09:00</published><updated>2024-01-10T21:00:00+09:00</updated><id>http://localhost:4000/%ED%8C%A8%EC%8A%A4%ED%8C%8C%EC%9D%B8%EB%8D%94/conflict/2024/01/10/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/%ED%8C%A8%EC%8A%A4%ED%8C%8C%EC%9D%B8%EB%8D%94/conflict/2024/01/10/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0.html"><![CDATA[<p>​<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FA6ni2%2Fbtsk1CjTRcs%2FQqlCB2OrK7jhEF8wpWKjTk%2Fimg.jpg" alt="썸네일" /></p>
<h2 id="동기비동기-정리">동기/비동기 정리</h2>

<p>동기/비동기는 자바스크립트에서 중요한 개념 중 하나이다. 동기는 코드가 순차적으로 실행된다는 것을 의미하며, 비동기는 코드가 순차적으로 실행되지 않는다는 것을 의미한다. 비동기 코드는 예측할 수 없는 순서로 실행되며, 실행이 완료되면 콜백 함수가 호출된다.</p>

<p>동기 코드의 예시는 다음과 같다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function add(x, y) {
  return x + y;
}

const result = add(1, 2);
console.log(result); // 3

</code></pre></div></div>

<p>위 코드에서 add 함수는 두 개의 숫자를 더한 값을 반환하는 일반적인 함수이다. 함수가 호출되면 결과가 즉시 반환되며, 결과는 result 변수에 할당된다. 이것은 동기 코드이다.</p>

<p>비동기 코드의 예시는 다음과 같다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setTimeout(() =&gt; {
  console.log('Hello, World!');
}, 1000);

</code></pre></div></div>

<p>위 코드에서 setTimeout 함수는 일정 시간이 지난 후에 실행될 콜백 함수를 등록하는 함수이다. 이 함수는 1초 후에 ‘Hello, World!’ 문자열을 콘솔에 출력한다. 이것은 비동기 코드이다. setTimeout 함수가 호출되면 결과가 즉시 반환되지 않으며, 1초 후에 콜백 함수가 호출된다.</p>

<p>따라서 자바스크립트에서는 비동기 함수를 항상 콜백 함수와 함께 사용해야 한다. 이를 통해 비동기 코드의 실행 순서를 보장하고, 비동기 함수가 완료된 후에 콜백 함수를 호출할 수 있다.</p>

<h2 id="예시">예시</h2>

<p>동기와 비동기를 이해하기 위해 일상 생활에서의 예시를 들어볼 수 있다.</p>

<p>예를 들어, 음식을 주문하는 것을 생각해보자. 동기 방식에서는 주문을 하면 음식이 나올 때까지 대기하며, 결과가 반환될 때까지 다른 일을 할 수 없다. 반면, 비동기 방식에서는 주문을 하고 나면 다른 스케줄을 세우거나, 다른 주문을 하거나, 롤이나 한 판 하는 등 다른 작업을 할 수 있다. 음식이 나오면 알림을 받아서 음식을 수령하고 먹으면 된다.</p>

<p>이와 같이 동기 방식은 결과가 반환될 때까지 대기해야 하며, 다른 작업을 수행할 수 없다. 반면, 비동기 방식은 결과가 반환되기를 기다리지 않고 다른 작업을 수행할 수 있다.</p>

<h1 id="예시-1">예시</h1>
<ul>
  <li>
    <h3 id="-시나리오-1-">[ 시나리오 1 ]</h3>
  </li>
  <li>개발팀장이 3명의 사원에게 동시다발적으로 각각의 업무를 지시한다. ( = 비동기 )</li>
  <li>놀랍게도 개발팀장은 3명의 사원에게 시킨 일을 확인도 안하고 본인 할 일도 한다 ( = 비동기 )</li>
  <li>
    <p>사원마다 맡은 일을 알아서 끝내고 개발팀장에게 보고한다. ( = 논블로킹 )</p>
  </li>
  <li>
    <h3 id="-시나리오-2-">[ 시나리오 2 ]</h3>
  </li>
  <li>개발팀장이 사원1 에게 업무를 지시한다.</li>
  <li>그리고 사원1 업무가 끝날때까지 언제 끝나냐고 눈초리를 준다. ( = 동기 )</li>
  <li>사원1 의 업무처리가 너무 느려서 다른 사원에게 일을 주려고한다. ( = 비동기 )</li>
  <li>그런데 사원1 은 도와달라며 개발팀장의 옷자락을 붙잡는다. ( = 블로킹 )</li>
  <li>그걸 지켜보는 사원2 와 사원3 은 무슨 일을 주던 열심히 할 생각은 있지만 일이 없다. ( = 동기 )</li>
</ul>

<h2 id="요약">요약</h2>

<p>동기/비동기 프로그래밍은 모든 프로그래밍 언어에서 중요한 개념 중 하나이다. 동기 프로그래밍은 코드가 순차적으로 실행되며, 결과가 즉시 반환된다는 것을 의미한다. 비동기 프로그래밍은 코드가 순차적으로 실행되지 않으며, 결과가 바로 반환되지 않는다는 것을 의미한다.</p>

<p>비동기 함수는 대개 비동기 콜백 함수와 함께 사용되며, 콜백 함수는 비동기 함수가 완료된 후에 호출된다. 이를 통해 프로그램이 예측 가능한 방식으로 실행되는 것을 보장할 수 있다. 예를 들어, 파일을 읽는 비동기 함수는 파일이 성공적으로 읽혔을 때 콜백 함수를 호출하여 결과를 반환한다.</p>

<p>동기 함수와 비동기 함수는 각각의 장단점이 있으며, 상황에 따라 적절한 방식을 선택해야 한다. 일반적으로, 네트워크 요청과 같은 오래 걸리는 작업을 수행할 때는 비동기 함수를 사용하는 것이 좋다. 이를 통해 사용자 인터페이스가 응답성을 유지하면서 백그라운드 작업이 수행될 수 있다.</p>

<h1 id="이해가-안-갈-까봐-예시를-더-만들어봤습니다">이해가 안 갈 까봐 예시를 더 만들어봤습니다</h1>

<h2 id="예시-1-커피-주문하기">예시 1: 커피 주문하기</h2>

<h3 id="동기적인-상황">동기적인 상황:</h3>
<p>고객이 커피 주문을 하면, 커피를 만드는 동안 다른 주문은 받지 않는다
주문이 완료되고 커피가 나오면, 그 다음 주문을 받는다</p>

<h3 id="비동기적인-상황">비동기적인 상황:</h3>
<p>고객이 커피 주문을 하면, 주문은 바로 받아들이고 고객에게 예상 소요 시간을 알려준다 
커피가 만들어지는 동안에도 다른 주문을 받아줄 수 있다
각 주문이 완료되면, 그때마다 손님에게 알림을 주고 커피를 준다.</p>

<p>동기적인 프로그래밍은 한 작업이 끝나야 다음 작업이 시작되는 반면, 비동기적인 프로그래밍은 여러 작업이 동시에 진행될 수 있고, 완료된 순서대로 결과를 얻을 수 있다는 것을 이해해야만 한다. 이러한 특성은 주로 네트워크 요청, 파일 다운로드, 사용자 인터랙션 등의 상황에서 뚜렷하게 나타난다.</p>]]></content><author><name>insidepixce</name></author><category term="conflict" /><category term="react" /><summary type="html"><![CDATA[​ 동기/비동기 정리]]></summary></entry></feed>