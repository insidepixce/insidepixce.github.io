<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-01-17T15:40:20+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Insidepixce</title><subtitle>살아가는 방법을 다룹니다</subtitle><author><name>insidepixce</name></author><entry><title type="html">20240117 TIL</title><link href="http://localhost:4000/til/all/2024/01/17/Namechange.html" rel="alternate" type="text/html" title="20240117 TIL" /><published>2024-01-17T15:30:00+09:00</published><updated>2024-01-17T15:30:00+09:00</updated><id>http://localhost:4000/til/all/2024/01/17/Namechange</id><content type="html" xml:base="http://localhost:4000/til/all/2024/01/17/Namechange.html"><![CDATA[<p>프로토타입/동적/정적, 그리고 프로그램은 어떻게 실행되는지 얕지만 깊게 파헤쳐보았다.</p>

<h1 id="20230117">20230117</h1>

<h1 id="프로토타입">🔥프로토타입</h1>

<h3 id="프로토타입이란">📖프로토타입이란</h3>

<p><strong>from book</strong></p>

<ul>
  <li>어떤 객체의 상위객체의 역할을 하는 객체</li>
  <li>하위(자식) 객체에게 자신의 프로퍼티와 메서드를 상속하며,</li>
  <li>프로토타입 객체의 프로퍼티나 메서드를 상속받은 하위 객체는 자신의 프로퍼티 또는 메서드인 것 처럼 자유롭게 사용할 수 있다 .</li>
</ul>

<h3 id="프로토타입의-예시-코드를-둘러보자">🌐프로토타입의 예시 코드를 둘러보자</h3>

<ul>
  <li>전체 코드</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Shape</span><span class="p">(</span><span class="nx">color</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="nx">color</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Shape</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getColor</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Color: </span><span class="dl">"</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">color</span><span class="p">);</span>
<span class="p">};</span>
<span class="kd">function</span> <span class="nx">Circle</span><span class="p">(</span><span class="nx">color</span><span class="p">,</span> <span class="nx">radius</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">Shape</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">color</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">=</span> <span class="nx">radius</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Circle</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">Shape</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
<span class="nx">Circle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">=</span> <span class="nx">Circle</span><span class="p">;</span>
<span class="nx">Circle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getArea</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Area: </span><span class="dl">"</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">**</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">redCircle</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Circle</span><span class="p">(</span><span class="dl">"</span><span class="s2">red</span><span class="dl">"</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="nx">redCircle</span><span class="p">.</span><span class="nx">getColor</span><span class="p">();</span> 
<span class="nx">redCircle</span><span class="p">.</span><span class="nx">getArea</span><span class="p">();</span>  
</code></pre></div></div>

<ol>
  <li>부모 객체 생성자 함수</li>
</ol>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Shape</span><span class="p">(</span><span class="nx">color</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="nx">color</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>부모 객체의 프로토타입에 메서드 추가</li>
</ol>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Shape</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getColor</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Color: </span><span class="dl">"</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">color</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<ol>
  <li>자식 객체 생성자 함수</li>
</ol>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Circle</span><span class="p">(</span><span class="nx">color</span><span class="p">,</span> <span class="nx">radius</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">Shape</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">color</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">=</span> <span class="nx">radius</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>프로토타입 체인 설정</li>
</ol>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Circle</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">Shape</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
<span class="nx">Circle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">=</span> <span class="nx">Circle</span><span class="p">;</span>
</code></pre></div></div>

<ol>
  <li>자식 객체의 프로토입에 메서드 추가</li>
</ol>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Circle</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getArea</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Area: </span><span class="dl">"</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">**</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<ol>
  <li>객체 생성</li>
</ol>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">redCircle</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Circle</span><span class="p">(</span><span class="dl">"</span><span class="s2">red</span><span class="dl">"</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</code></pre></div></div>

<ol>
  <li>프로토타입 체인을 통한 상속을 확인하기 위해 호출해보기</li>
</ol>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">redCircle</span><span class="p">.</span><span class="nx">getColot</span><span class="p">();</span>
<span class="nx">redCircle</span><span class="p">.</span><span class="nx">getArea</span><span class="p">();</span>
</code></pre></div></div>

<hr />

<p><code class="language-plaintext highlighter-rouge">shape</code> 는 부모 객체의 생성자 함수이며, <code class="language-plaintext highlighter-rouge">circle</code>은 자식 객체의 생성자 함수이다 .</p>

<p><code class="language-plaintext highlighter-rouge">circle</code> 는 <code class="language-plaintext highlighter-rouge">shape</code> 를 상속받아 <code class="language-plaintext highlighter-rouge">getColor</code> 메서드를 사용하고 동시에 <code class="language-plaintext highlighter-rouge">getArea</code> 메서드를 추가로 정의한다.</p>

<p><code class="language-plaintext highlighter-rouge">redcircle</code> 객체는 <code class="language-plaintext highlighter-rouge">Circle</code> 의 인스턴스이면서 <code class="language-plaintext highlighter-rouge">Shape</code> 의 프로토타입을 따라간다</p>

<p>이렇게 프로토타입 체인을 통해 상속된 메서드들을 호출할 수 있다</p>

<hr />

<aside>
💡 자바스크립트는 프로토 타입 기반의 언어이지만 자바는 클래스 기반의 상속을 사용한다. 클래스로부터 객체를 생성하고 상속을 통해 클래스의 속성과 메서드를 자식 클래스에서 사용한다.

</aside>

<aside>
💡 자바에서 클래스의 상속은 `extends` 키워들르 사용하여 이루어진다. 자식 클래스에서 추가적인 속성이나 메서드를 정의할 수 있따.

</aside>

<h2 id="클래스-기반-vs-프로토타입-객체-기반">🚀클래스 기반 vs 프로토타입 객체 기반</h2>

<h3 id="1선언-방식">📢1.선언 방식</h3>

<p>프로토타입 : 생성자 함수와 프로토타입 객체를 사용하여 상속을 선언함</p>

<p>클래스:  클래스를 정의하고 <code class="language-plaintext highlighter-rouge">extends</code> 키워드를 사용하여 상속을 선언합니다</p>

<h3 id="️2-인스턴스-생성">⚒️2. 인스턴스 생성</h3>

<p>프로토타입 : <code class="language-plaintext highlighter-rouge">Object.create()</code>나 생성자 함수와 <code class="language-plaintext highlighter-rouge">new</code> 키워드를 사용하여 인스턴스를 생성함</p>

<p>클래스 : 클래스 기반 언어에서는 클래스의 생성자를 호출하여 객체를 생성한다</p>

<h3 id="3-동적성">😳3. 동적성</h3>

<p>프로토타입 : 프로토타입 상속은 동적 (런타임에 프로토타입 객체를 변경할 수 있다)</p>

<p>클래스 : 클래스 기반 언어에서는 정적 (클래스 정의 이후에는 변경 어려움)</p>

<h2 id="️문제-만들기">⁉️문제 만들기</h2>

<h3 id="️1-이-코드의-실행결과는-무엇인가-">🖥️1. 이 코드의 실행결과는 무엇인가 ?</h3>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Animal</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">eat</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">가 먹고있다</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">};</span>
  
  <span class="kd">function</span> <span class="nx">Dog</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">breed</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">Animal</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">breed</span> <span class="o">=</span> <span class="nx">breed</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="nx">Dog</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
  <span class="nx">Dog</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">=</span> <span class="nx">Dog</span><span class="p">;</span>
  <span class="nx">Dog</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">bark</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">가 짖고있다</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">};</span>
  
  <span class="kd">var</span> <span class="nx">myDog</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Dog</span><span class="p">(</span><span class="dl">"</span><span class="s2">콜라</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">푸들</span><span class="dl">"</span><span class="p">);</span>
  
  <span class="nx">myDog</span><span class="p">.</span><span class="nx">eat</span><span class="p">();</span>
  <span class="nx">myDog</span><span class="p">.</span><span class="nx">bark</span><span class="p">();</span>
</code></pre></div></div>

<p><strong>풀이 전 보고 가자</strong></p>

<hr />

<p>프로토타입 체인은 js에서 객체 간 상속을 구현하는 매커니즘이다. 각 개체는 자체 프로퍼티와 메서드를 가지고 있다.</p>

<p>객체의 <code class="language-plaintext highlighter-rouge">prototype</code> 프로퍼티는 해당 객체가 상속받은 프로토타입 객체를 가리키며, 이 프로토타입 객체 또한 자신의 <code class="language-plaintext highlighter-rouge">prototype</code> 를 가리키는 식으로 연결된다.</p>

<p>이런 방식으로 객체는 지속적으로 프로토타입을 따라가며 속성과 메서드를 찾아나간다</p>

<hr />

<p><strong>풀이</strong></p>

<hr />

<p><code class="language-plaintext highlighter-rouge">mydog.eat()</code> 은 <code class="language-plaintext highlighter-rouge">myDog</code> 가 <code class="language-plaintext highlighter-rouge">Dog</code> 의 인스턴스이기 때문에 <code class="language-plaintext highlighter-rouge">Dog</code> 의 프로토타입 체인을 따라가면서 <code class="language-plaintext highlighter-rouge">Animal</code> 의 <code class="language-plaintext highlighter-rouge">eat</code>  메서드를 호출한다</p>

<p>출력 :“콜라가 먹고있다”</p>

<p><code class="language-plaintext highlighter-rouge">myDog.bark();</code> 은 <code class="language-plaintext highlighter-rouge">Dog</code> 의 고유 메서드인 <code class="language-plaintext highlighter-rouge">bark</code> 를 호출한다</p>

<p>출력 : “콜라가 짖고있다”</p>

<hr />

<h3 id="️2-이-조건에-맞춰-코드-써봐">🖥️2. 이 조건에 맞춰 코드 써봐.</h3>

<ol>
  <li>조건
    <ul>
      <li>두 개의 생성자 함수가 주어집니다  (person, student)</li>
      <li>person 생성자 함수는 name이라는 속성을 가지고 있습니다</li>
      <li>student 생성자 함수는 school이라는 속성을 가지고 있습니다</li>
      <li>student 객체는 person 객체를 상속받아야 함</li>
    </ul>
  </li>
  <li>요구사항
    <ul>
      <li>person 생성자 함수를 직접 수정하지 않고 student 생성자 함수에서 pesron 객체를 상속받아야 함</li>
      <li>student 생성자 함수로 생성된 객체는 name 과 school 속성을 가질 수 있어야 함</li>
    </ul>
  </li>
  <li>예상되는 출력값
    <ul>
      <li>student 객체를 생성하여 name과 school 속성을 출력하면 각각의 값이 나와야 함</li>
    </ul>
  </li>
</ol>

<h1 id="생성자-함수">🚀생성자 함수</h1>

<h3 id="️-객체-초기화">⭐️ 객체 초기화</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">this</code> 키워드를 사용하여 새로운 객체를 초기화함</li>
  <li>생성자 함수를 호출하면  객체가 생성되고 이 객체는 생성자 함수 내부의 코드에 따라 속성/메서드로 초기화됨</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="p">;</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span> <span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">soojin</span><span class="dl">"</span><span class="p">,</span> <span class="mi">21</span><span class="p">);</span>

</code></pre></div></div>

<hr />

<h3 id="️-new-키워드-사용">⭐️ <code class="language-plaintext highlighter-rouge">new</code> 키워드 사용</h3>

<ul>
  <li>생성자 함수를 호출할 때 <code class="language-plaintext highlighter-rouge">new</code> 키워드를 사용하여 새로운 인스턴스를 생성함</li>
  <li><code class="language-plaintext highlighter-rouge">new</code> 를 사용하면 새로운 객체가 생성되고 생성자 함수 내의 코드가 실행됨</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">soojin</span><span class="dl">"</span><span class="p">,</span> <span class="mi">21</span><span class="p">);</span>
</code></pre></div></div>

<hr />

<h3 id="️-프로토타입-활용">⭐️ 프로토타입 활용</h3>

<ul>
  <li>생성자 함수는 일반적으로 프로토타입을 사용하여 모든 인스턴스가 공유할 수 있는 메서드나 속성을 정의한다</li>
  <li>이는 메모리를 효율적으로 사용하고 중복 코드를 방지한다</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayHello</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">안녕하세요 제 이름은</span><span class="dl">"</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">Soojin</span><span class="dl">"</span><span class="p">,</span> <span class="mi">21</span><span class="p">);</span>
<span class="nx">person1</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">();</span> 
</code></pre></div></div>

<hr />

<h3 id="️-this-키워드">⭐️ <code class="language-plaintext highlighter-rouge">this</code> 키워드</h3>

<ul>
  <li>생성자 함수 내에서 <code class="language-plaintext highlighter-rouge">this</code> 는 새로 생성되는 객체를 가리킨다</li>
  <li>생성자 함수를 통해 속성이나 메서드를 할당할 때 <code class="language-plaintext highlighter-rouge">this</code> 를 사용하여 현재 생성되고 있는 객체에 대한 참조를 얻을 수 있다</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Car</span> <span class="p">(</span><span class="nx">make</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">make</span> <span class="o">=</span> <span class="nx">make</span><span class="p">;</span> 
	<span class="k">this</span><span class="p">.</span><span class="nx">model</span> <span class="o">=</span> <span class="nx">model</span><span class="p">;</span> 
	<span class="k">this</span><span class="p">.</span><span class="nx">start</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">엔진이 시작됨</span><span class="dl">"</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">make</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">  </span><span class="dl">"</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">)</span><span class="dl">'</span><span class="s1">
	};
}
var myCar = new Car ("toyota", "Carmy:");
myCar.start();
</span></code></pre></div></div>

<h1 id="동적과-정적에-관하여">🚀동적과 정적에 관하여</h1>

<h2 id="️️1-동적">🏋️‍♂️ 1. 동적</h2>

<ul>
  <li>프로그램 실행 중에 변수의 타입이나 속성이 결정됨</li>
  <li>코드 실행 시간에 유연성을 제공하며, 타입이나 속성을 변경할 수 있음</li>
  <li>js, python 등은 동적 언어</li>
  <li>웹개발, 스크립팅 언어 등에서 자주 쓰임</li>
  <li>빠른 프로토타이핑과 개발 생산성이 요구되는 환경에서 유용</li>
</ul>

<p>→ 변수의 타입이 런타임에 정해짐</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">dynamicVariable</span><span class="p">;</span>  <span class="c1">// 변수 선언 (타입은 현재 undefined)</span>

<span class="nx">dynamicVariable</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>  <span class="c1">// 숫자 타입으로 할당</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">dynamicVariable</span><span class="p">);</span>  <span class="c1">// 출력: number</span>

<span class="nx">dynamicVariable</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, world!</span><span class="dl">"</span><span class="p">;</span>  <span class="c1">// 문자열 타입으로 할당</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">dynamicVariable</span><span class="p">);</span>  <span class="c1">// 출력: string</span>

<span class="nx">dynamicVariable</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>  <span class="c1">// 불리언 타입으로 할당</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">dynamicVariable</span><span class="p">);</span>  <span class="c1">// 출력: boolean</span>
</code></pre></div></div>

<p>→ 동일한 변수가 다양한 타입을 가질 수 있음</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">dynamicVariable</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// 숫자 타입</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">dynamicVariable</span><span class="p">);</span> <span class="c1">// 42</span>

<span class="nx">dynamicVariable</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, world!</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// 문자열 타입</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">dynamicVariable</span><span class="p">);</span> <span class="c1">// Hello, world!</span>
</code></pre></div></div>

<h2 id="2-정적">💤 2. 정적</h2>

<ul>
  <li>컴파일 시간에 변수의 타입이나 속성이 결정됨</li>
  <li>컴파일러는 타입 체크를 수행하고 오류를 런타임 이전에 찾을 수 있음</li>
  <li>java, c++ , c# 등은 정적 언어</li>
  <li>대규모 시스템 및 안정성이 중요한 프로젝트에서 사용됨</li>
  <li>컴파일러에 의한 타입 체크로 런타임 오류 방지하고 성능 최적화</li>
</ul>

<p>→ 변수의 타입은 선언 시점에 명시됨 , 해당 타입에 맞는 값만 할당할 수 있음</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">public</span> <span class="kd">class</span> <span class="nx">StaticExample</span> <span class="p">{</span>
    <span class="kr">public</span> <span class="kd">static</span> <span class="k">void</span> <span class="nx">main</span><span class="p">(</span><span class="nb">String</span><span class="p">[]</span> <span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">int</span> <span class="nx">staticVariable</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// 정수 타입</span>
        <span class="nx">System</span><span class="p">.</span><span class="nx">out</span><span class="p">.</span><span class="nx">println</span><span class="p">(</span><span class="nx">staticVariable</span><span class="p">);</span>

        <span class="c1">// 아래 주석을 해제하면 컴파일 오류 발생</span>
        <span class="c1">// staticVariable = "Hello, world!"; // 문자열 할당은 허용되지 않음</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위의 코드에서 <code class="language-plaintext highlighter-rouge">staticVariable</code> 은 정수 타입으로 선언됨 → 정수 값인 42를 할당할 수 있음</p>

<p>but 나중에 문자열을 할당하려고 시도하면 컴파일 오류 발생</p>

<p><code class="language-plaintext highlighter-rouge">anotherVariable</code>을 선언할때는 명시적으로  <code class="language-plaintext highlighter-rouge">double</code> 타입을 지정하여 실수 값 할당</p>

<h2 id="3-정적-페이지">🤺3. 정적 페이지</h2>

<h3 id="️정적-페이지의-특징">⭐️정적 페이지의 특징</h3>

<ul>
  <li>고정된 컨텐츠를 제공하는 웹 페이지</li>
  <li>사용자의 요청에 따라 콘텐츠가 생성되거나 변경되지 않고 고정된 상태를 유지함</li>
  <li>주로 HTML CSS 이미지 등의 정적 리소스로 이루어져 있음</li>
</ul>

<h3 id="정적-페이지의-예시">🔥정적 페이지의 예시</h3>

<ul>
  <li>블로그의 고정된 페이지</li>
  <li>회사 소개 페이지</li>
</ul>

<p>→ 서버에 미리 저장되어 있으며, 클라이언트 요청 시에는 서버에서 그대로 전달됨</p>

<h2 id="4-동적-페이지">😪4. 동적 페이지</h2>

<h3 id="️-동적-페이지의-특징">⭐️ 동적 페이지의 특징</h3>

<ul>
  <li>사용자의 요청에 따라 콘텐츠가 동적으로 생성되거나 변경되는 웹 페이지</li>
  <li>서버 측 프로그램이나 스크립트를 사용하여 사용자에게 맞춤형 컨텐츠를 동적으로 생성</li>
  <li>주로 데이터베이스와의 상호작용이나 사용자 입력에 따라 동적으로 변하는 콘텐츠 제공</li>
</ul>

<h3 id="동적-페이지의-예시">🔥동적 페이지의 예시</h3>

<ul>
  <li>소셜 미디어 피드, 온라인 쇼핑몰의 상품 목록 등이 동적 페이지의 예시</li>
  <li>사용자의 요청에 따라 서버에서 데이터를 가공하여 동적으로 생성되므로 항상 최신 정보 제공</li>
  <li>주로 백엔드 프로그래밍 언어(php python node java)와 데이터베이스를 사용하여 콘텐츠를 동적으로 생성하며, 서버에서 실행되고 클라이언트에 전달함</li>
</ul>

<blockquote>
  <p>정적 페이지는 서버에 미리 생성되어 있어 서버 부하가 낮고 로딩 속도가 빠르나 동적 페이지는 서버에서 동적으로 생성되기 때문에 서버 부하가 있을 수 있고 로딩속도가 상대적으로 느림</p>

</blockquote>

<hr />

<h1 id="프로그램이-어떻게-실행되냐고">🚀프로그램이 어떻게 실행되냐고?</h1>

<h2 id="1-선언">💬1. 선언</h2>

<h3 id="️자바스크립트">⭐️자바스크립트</h3>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">var</code></strong>, <strong><code class="language-plaintext highlighter-rouge">let</code></strong>, <strong><code class="language-plaintext highlighter-rouge">const</code></strong> 등의 키워드를 사용하여 변수를 선언함</li>
  <li>
    <p>함수 선언, 클래스 선언도 포함</p>

    <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nx">javascriptCopy</span> <span class="nx">code</span>
  <span class="kd">let</span> <span class="nx">x</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">myFunction</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 함수 내용</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="️자바">⭐️자바</h3>

<ul>
  <li>클래스, 변수, 메서드 등을 선언</li>
  <li>
    <p>자료형이 명시적으로 필요한 경우가 많음</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">javaCopy</span> <span class="n">code</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
      <span class="kt">void</span> <span class="nf">myMethod</span><span class="o">()</span> <span class="o">{</span>
          <span class="c1">// 메서드 내용</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="️파이썬">⭐️파이썬</h3>

<ul>
  <li>변수를 선언하거나 함수를 정의함</li>
  <li>
    <p>자료형이 명시적으로 필요하지 않다</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">pythonCopy</span> <span class="n">code</span>
  <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
  <span class="k">def</span> <span class="nf">my_function</span><span class="p">():</span>
      <span class="c1"># 함수 내용
</span></code></pre></div>    </div>
  </li>
</ul>

<h2 id="2-컴파일">👩🏼‍💻2. 컴파일</h2>

<hr />

<h3 id="️인터프리터">🖥️인터프리터</h3>

<ol>
  <li>
    <p><strong>동적 타입 언어</strong></p>

    <p>주로 동적 타입 언어(예: 파이썬, 자바스크립트)에서 사용됩니다. 동적 타입 언어는 실행 시간에 타입을 확인하고 필요한 경우 동적으로 타입을 변환합니다.</p>
  </li>
  <li>
    <p><strong>코드 실행 중 에러 확인</strong></p>

    <p>소스 코드를 실행 중에 한 줄씩 읽고 실행하므로, 코드 실행 중 에러가 발생하면 해당 부분이 바로 확인됩니다.</p>
  </li>
  <li>
    <p><strong>간단한 디버깅</strong></p>

    <p>에러가 발생하는 코드를 발견하면 즉시 중단하고 해당 부분을 수정할 수 있습니다.</p>
  </li>
  <li>
    <p><strong>코드 실행 속도가 느릴 수 있음</strong></p>

    <p>컴파일러에 비해 일반적으로 실행 속도가 느릴 수 있습니다. 매번 코드를 해석하고 실행하기 때문입니다.</p>
  </li>
</ol>

<p><strong>인터프리터의 동작 과정:</strong></p>

<ol>
  <li><strong>토큰화 및 구문 분석:</strong> 소스 코드를 토큰으로 분해하고 구문 분석하여 AST 생성.</li>
  <li><strong>실행 및 해석:</strong> AST를 읽고, 각 문장을 순차적으로 실행하여 결과를 출력.</li>
</ol>

<h3 id="️컴파일러">🖥️컴파일러</h3>

<ol>
  <li>
    <p><strong>정적 타입 언어</strong></p>

    <p>주로 정적 타입 언어(예: C, C++, Java)에서 사용됨 정적 타입 언어는 변수의 자료형을 선언하고, 컴파일 시간에 타입을 확인</p>
  </li>
  <li>
    <p><strong>컴파일 타임 오류</strong></p>

    <p>컴파일러는 소스 코드를 분석하고, 타입 체크 등을 수행함→  컴파일 타임에 오류를 검출할 수 있다</p>
  </li>
  <li>
    <p><strong>기계어 또는 중간 코드 생성</strong></p>

    <p>소스 코드를 목적 언어(기계어) 또는 중간 코드로 변환</p>
  </li>
  <li>
    <p><strong>전체 소스 코드 컴파일</strong></p>

    <p>소스 코드의 전체를 컴파일하여 실행 파일을 생성</p>
  </li>
</ol>

<p><strong>컴파일러의 동작 과정:</strong></p>

<ol>
  <li><strong>토큰화 및 구문 분석:</strong> 소스 코드를 토큰으로 분해하고 구문 분석하여 AST 생성.</li>
  <li><strong>의미 분석:</strong> 변수, 함수 호출 등의 의미를 확인.</li>
  <li><strong>코드 생성:</strong> 목적 언어(기계어)로 코드 생성.</li>
  <li><strong>최적화:</strong> 생성된 코드를 최적화.</li>
  <li><strong>링킹:</strong> 필요한 라이브러리와 연결하여 실행 파일 생성.</li>
</ol>

<aside>
💡 컴파일러는 소스 코드를 기계어로 변환하고, 변환된 코드를 실행 파일로 저장한다. 모든 소스코드를 미리 컴파일해야 함으로 실행 전에 시간이 소요된다. 실행 파일은 플랫폼에 종속적이다

</aside>

<aside>
💡 인터프리터는 소스 코드를 직접 실행하고 중간 단계의 실행 파일이 생성되지 않는다. 실행 시간에 코드를 해석하므로 빠르게 결과를 얻을 수 있다. 일반적으로 플랫폼 독립적이지만, 플랫폼에 따라 구현 방식이 좀 다르다

</aside>

<p>추후 다뤄봐야 할 주제 : 플랫폼 종속적, 독립적</p>

<hr />

<h3 id="️자바스크립트에서의-컴파일">⭐️자바스크립트에서의 컴파일</h3>

<ul>
  <li>일반적으로 브라우저에서 직접 실행되므로 명시적인 컴파일 단계가 없음</li>
  <li>대신 인터프리터에 의해 해석됨 → 컴파일 안 함</li>
</ul>

<h3 id="️자바에서의-컴파일">⭐️자바에서의 컴파일</h3>

<ul>
  <li>자바 코드는 컴파일러에 의해 바이트코드로 변환</li>
  <li>바이트코드는 Java 가상 머신(JVM)에서 실행</li>
</ul>

<h3 id="️파이썬에서의-컴파일">⭐️파이썬에서의 컴파일</h3>

<ul>
  <li>파이썬 코드는 바이트코드로 변환되고, 이는 파이썬 인터프리터에 의해 실행됩니다.</li>
  <li>파이썬은 컴파일과 실행이 결합된 형태를 가지고 있습니다.</li>
</ul>

<hr />

<h2 id="️3-런타임">🏃🏻‍♀️3. 런타임</h2>

<h3 id="️자바스크립트-1">⭐️자바스크립트</h3>

<ul>
  <li>브라우저나 Node.js🖥️같은 환경에서 코드가 실행</li>
</ul>

<h3 id="️자바-1">⭐️자바</h3>

<ul>
  <li>자바 가상 머신 (JVM)에서 바이트코드가 실행</li>
</ul>

<h3 id="️파이썬-1">⭐️파이썬</h3>

<ul>
  <li>파이썬 인터프리터에서 코드가 실행</li>
</ul>

<hr />

<h1 id="그래서-어떻게-실행되는지-하나씩-정리해줄게-">🚀그래서 어떻게 실행되는지 하나씩 정리해줄게 !</h1>

<h3 id="️자바스크립트-동적-타입-언어">⭐️<strong>자바스크립트 (동적 타입 언어):</strong></h3>

<ol>
  <li><strong>선언 (Declaration)</strong>
    <ul>
      <li>변수나 함수 등을 선언</li>
    </ul>
  </li>
  <li><strong>런타임 (Runtime)</strong>
    <ul>
      <li>코드가 실행되면서 변수의 타입이 동적으로 결정</li>
      <li>변수에 값을 할당하거나 함수를 호출하는 등의 동작이 런타임에 이루어짐</li>
    </ul>
  </li>
</ol>

<h3 id="️자바-정적-타입-언어">⭐️<strong>자바 (정적 타입 언어)</strong></h3>

<ol>
  <li><strong>선언 (Declaration)</strong>
    <ul>
      <li>클래스, 변수, 메서드 등을 선언하고, 변수의 타입이 명시</li>
    </ul>
  </li>
  <li><strong>컴파일 (Compilation)</strong>
    <ul>
      <li>소스 코드가 바이트코드로 변환되어 컴파일</li>
    </ul>
  </li>
  <li><strong>런타임 (Runtime)</strong>
    <ul>
      <li>JVM(Java Virtual Machine)에서 바이트코드가 실행</li>
    </ul>
  </li>
</ol>

<h3 id="️파이썬-동적-타입-언어">⭐️<strong>파이썬 (동적 타입 언어)</strong></h3>

<ol>
  <li><strong>선언 (Declaration)</strong>
    <ul>
      <li>변수나 함수 등을 선언. 변수에 대한 타입 선언은 필요하지 않음.</li>
    </ul>
  </li>
  <li><strong>런타임 (Runtime)</strong>
    <ul>
      <li>코드가 실행되면서 변수의 타입이 동적으로 결정.</li>
      <li>변수에 값을 할당하거나 함수를 호출하는 등의 동작이 런타임에 이루어짐.</li>
    </ul>
  </li>
</ol>]]></content><author><name>insidepixce</name></author><category term="all" /><category term="react" /><summary type="html"><![CDATA[프로토타입/동적/정적, 그리고 프로그램은 어떻게 실행되는지 얕지만 깊게 파헤쳐보았다.]]></summary></entry><entry><title type="html">20240116 TIL</title><link href="http://localhost:4000/til/all/2024/01/16/Today.html" rel="alternate" type="text/html" title="20240116 TIL" /><published>2024-01-16T21:27:00+09:00</published><updated>2024-01-16T21:27:00+09:00</updated><id>http://localhost:4000/til/all/2024/01/16/Today</id><content type="html" xml:base="http://localhost:4000/til/all/2024/01/16/Today.html"><![CDATA[<h1 id="20230116--프로퍼티-어트리뷰트">20230116 : 프로퍼티 어트리뷰트</h1>

<h1 id="제일-먼저-개념-잡고가기---프로퍼티">제일 먼저 개념 잡고가기 - 프로퍼티</h1>

<p>프로퍼티는 객체 내에서 객체의 상태를 나타내는 특징적인 특성을 의미한다</p>

<p>객체 지향 프로그래밍에서 객체는 데이터와 그 데이터를 조작하는 동작 (메서드)를 함께 포하하는 개념적인 단위</p>

<p>객체의 데이터는 프로퍼티로 표현되고 그 동작은 메서드로 표현된다</p>

<p>KEY값과 VALUE값으로 구성되며 키는 일반적으로 문자열이나 심볼이 된다. 값은 어떤 데이터 타입이여도 가능.</p>

<p>이렇게 객체 내에서 프로퍼티는 객체의 상태나 특성을 나타내며 프로퍼티의 값은 해당 상태의 실제 데이터를 담고 있다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 객체 생성</span>
<span class="kd">let</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{};</span>

<span class="c1">// 프로퍼티 추가</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

<span class="c1">// 프로퍼티 접근</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// 출력: John</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span>  <span class="c1">// 출력: 30</span>
</code></pre></div></div>

<p>위의 예제에서 <code class="language-plaintext highlighter-rouge">name</code>과 <code class="language-plaintext highlighter-rouge">age</code>는 <code class="language-plaintext highlighter-rouge">person</code> 객체의 프로퍼티이다.</p>

<p>객체는 이러한 프로퍼티들의 집합이며, 프로퍼티들은 해당 객체의 특징과 데이터를 정의한다</p>

<h1 id="161-내부-슬롯과-내부-메서드">16.1 내부 슬롯과 내부 메서드</h1>

<h2 id="1-개념-정리하기">1. 개념 정리하기</h2>

<p>→ 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용</p>

<p>→  의사 프로퍼티와 의사 메서드</p>

<p>→ 이중 대괄호로 감싼 이름들이 내부 슬롯과 내부 매서드이다</p>

<h2 id="2-내부-슬롯">2. 내부 슬롯</h2>

<p>객체의 내부 상태를 나타냄</p>

<p>→ 언어 자체의 구현을 위해 사용되며, javascript 코드에서 직접적으로 접근하거나 조작할 수 없다ㅣ</p>

<p>→ 내부 상태 및 동작을 유지하고 제어하는 데 사용됨</p>

<p>ex) <code class="language-plaintext highlighter-rouge">[[Prototype]]</code> ,<code class="language-plaintext highlighter-rouge">[[Extensible]]</code> 같은 속성들이 내부 슬롯에 해당됨</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span> 
</code></pre></div></div>

<p>결과로는 [Object: null prototype]이 출력된다.</p>

<p>→ 빈 객체 <code class="language-plaintext highlighter-rouge">obj</code> 를 생성하고 그 객체의 프로토타입을 출력하는 코드이다.</p>

<p>실행 결과로는 <code class="language-plaintext highlighter-rouge">object.prototype</code> 에 대한 정보가 나온다.</p>

<p>빈 객체의 경우, 이 객체는 기본적으로 <code class="language-plaintext highlighter-rouge">object.prototpye</code> 을 상속하므로 결과로는  <code class="language-plaintext highlighter-rouge">[object : null prototype]</code> 가 출력된다.</p>

<h3 id="잠깐-프로토타입이-뭐냐고">🤵🏻 잠깐, 프로토타입이 뭐냐고?</h3>

<p>→ 자바스크립트에서 객체지향 프로그래밍의 핵심 개념 중 하나이다.</p>

<p>→ 객체는 다른 객체로부터 상속 받을 수 있는데, 이때 상속을 받는 객체를 “프로토타입 객체”라고 한다</p>

<h3 id="️프로토타입-체인">⛓️ <strong>프로토타입 체인</strong></h3>

<ul>
  <li>모든 객체는 프로토타입을 가진다</li>
  <li>객체의 프로토타입은 다른 객체이며, 이 객체 또한 자신의 프로토타입을 가질 수 있다.</li>
  <li>이런식으로 여러 객체가 연결된 구조를 프로토타입 체인이라고 한다</li>
</ul>

<h3 id="프로토타입-객체">🌐 <strong>프로토타입 객체</strong></h3>

<ul>
  <li>모든 객체는 자체 속성 및 메서드를 가진다</li>
  <li>이를 프로토타입 객체라고 한다</li>
  <li>객체를 생성할 때마다 해당 객체의 프로토타입이 결정된다</li>
  <li>객체의 프로토타입은 다른 객체이며 이로 인해 상속 관계가 형성된다</li>
</ul>

<aside>
💡 즉, 프로토타입이란 객체 간에 상속을 구현하는 매커니즘

</aside>

<h2 id="3-내부-메서드">3. 내부 메서드</h2>

<p>객체의 내부 동작을 정의하는 메서드로, 주로 스펙에서 언급되는 추상 연산에 대응된다</p>

<p>이러한 내부 메서드는 특정 객체 타입이나 기능에 따라 어떻게 동작해야 하는질ㄹ 규정한다</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">key</span><span class="p">:</span> <span class="dl">'</span><span class="s1">value</span><span class="dl">'</span> <span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">key</span><span class="p">);</span> <span class="c1">// 내부 메서드 [[Get]] 호출</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">key</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">new value</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// 내부 메서드 [[Set]] 호출</span>
</code></pre></div></div>

<p>→ 모든 객체는 내부 메서드인 <code class="language-plaintext highlighter-rouge">[[GET]]</code>및 <code class="language-plaintext highlighter-rouge">[[SET]]</code>를 가지고 있어서 속성에 접근하거나 값을 설정할때 호출됨</p>

<h3 id="추상-연산이란">➕ 추상 연산이란?</h3>

<p>ECMAScript 스펙에서 언급되는 추상연산이란 특정한 동작을 수행하는데 사용되는 논리적인 단계들의 집합이다.</p>

<ul>
  <li>언어의 구현에 대한 명세 제공</li>
  <li>어떤 기능이나 동작이 어떻게 이루어져야 하는지 정의</li>
</ul>

<p>→ 추상은 구체적인 구현이나 환경에 의존하지 않고 일반적인 개념적인 수준에서 정의된다는 의미이다.</p>

<ol>
  <li><strong>ToPrimitive (input [, PreferredType])</strong>: 이 추상 연산은 특정 값의 원시 값 변환을 수행힌다 <strong><code class="language-plaintext highlighter-rouge">PreferredType</code></strong>은 변환되길 원하는 타입을 나타낸다</li>
  <li><strong>ToBoolean (argument)</strong>: 이 추상 연산은 특정 값을 불리언 값으로 변환</li>
  <li><strong>ToObject (argument)</strong>: 이 추상 연산은 특정 값을 객체로 변환한다</li>
</ol>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">valueOf</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="na">toString</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="dl">"</span><span class="s2">Hello</span><span class="dl">"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">obj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// ToPrimitive(obj) + 1</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span> <span class="c1">// 43</span>
</code></pre></div></div>

<p>이 코드에서 <strong><code class="language-plaintext highlighter-rouge">+</code></strong> 연산자는 “ToPrimitive” 추상 연산을 사용하여 객체 <strong><code class="language-plaintext highlighter-rouge">obj</code></strong>를 원시 값으로 변환한 후에 덧셈함</p>

<p>→ valueOF 메서드가 호출되어 객체를 숫자로 변환하고 최종적으로 42에 1이 더해져 43이라는 결과를 얻음</p>

<hr />

<h1 id="162-프로퍼티-어트리뷰트와--프로퍼티-디스크립터-객체">16.2 프로퍼티 어트리뷰트와  프로퍼티 디스크립터 객체</h1>

<h2 id="1-막혀버린-곳">1. 막혀버린 곳</h2>

<aside>
💡 자바스크립트 엔진은 프로퍼티를 생성할 떄 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본

값으로 자동 정의한다 

</aside>

<p>책 보다가 이게 무슨 소리인지 감이 안 잡혔다</p>

<p>→ 엔진이 객체의 프로퍼티를 생성할 때 , 해당 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 자동으로 기본값으로 정의한다는 것이다</p>

<h2 id="2-엔진이-프로퍼티를-생성해-내는-과정">2. 엔진이 프로퍼티를 생성해 내는 과정</h2>

<h3 id="️cs관점에서-보는-프로퍼티-생성하기">🖥️ CS관점에서 보는 프로퍼티 생성하기</h3>

<ul>
  <li><strong>메모리 할당</strong></li>
</ul>

<p>객체는 메모리상에 저장되어야 한다.</p>

<ul>
  <li><strong>프로퍼티 초기화</strong></li>
</ul>

<p>프로퍼티를 초기화하려면 메모리에 해당 프로퍼티의 값을 저장해야한다</p>

<p>이때, 프로퍼티의 이름과 값을 기반으로 메모리에 공간을 확보하고 값을 저장한다</p>

<ul>
  <li><strong>프로퍼티 어트리뷰트 설정</strong></li>
</ul>

<p>프로퍼티의 어트리뷰트(예: <strong><code class="language-plaintext highlighter-rouge">writable</code></strong>, <strong><code class="language-plaintext highlighter-rouge">enumerable</code></strong>, <strong><code class="language-plaintext highlighter-rouge">configurable</code></strong>)를 설정한다.</p>

<p>이러한 정보는 프로퍼티의 동작을 제어하며, 어떻게 다뤄져야 하는지를 나타낸다</p>

<ul>
  <li><strong>프로토타입 체인 설정:</strong></li>
</ul>

<p>객체의 프로퍼티가 프로토타입 체인에 연결될 경우, 이를 설정한다</p>

<p>이것은 프로퍼티에 직접 접근할 수 없을 때 프로토타입 체인을 따라가며 해당 프로퍼티를 찾을 수 있도록 하는 매커니즘이다</p>

<ul>
  <li><strong>참조(Reference) 반환</strong></li>
</ul>

<p>생성된 객체의 참조(메모리 주소 등)를 반환하여 이를 변수에 할당하거나 다른 객체와 관계를 설정한다</p>

<h3 id="️프로퍼티를-초기화하려면-해당-프로퍼티의-값을-저장해야-한다며-왜-그래야-해">🙋🏻‍♀️ 프로퍼티를 초기화하려면 해당 프로퍼티의 값을 저장해야 한다며, 왜 그래야 해?</h3>

<p>프로퍼티를 초기화하려면 해당 프로퍼티에 값을 할당하고, 이 값을 메모리에 저장해야 한다.</p>

<p>이는 컴퓨터의 메모리는 데이터를 저장하고 유지하기 위한 공간이기 때문이다.</p>

<ol>
  <li><strong>메모리 할당:</strong> 프로퍼티를 포함하는 객체는 메모리 상의 특정 위치에 저장되며 이 위치에는 객체의 모든 프로퍼티에 대한 정보가 저장된다</li>
  <li><strong>프로퍼티 값 저장:</strong> 프로퍼티는 그 값과 함께 메모리에 저장된다.  이 값은 변수의 데이터 타입에 따라 다르게 저장된다. 
예를 들어, 정수, 부동 소수점, 문자열 등의 값을 저장하는 방식이 다를 수 있습다.</li>
  <li><strong>프로퍼티 값에 대한 참조:</strong> 객체 내의 각 프로퍼티에 대한 값은 해당 프로퍼티에 대한 참조로써 사용된다. 
이 참조는 메모리 위치를 나타내고, 프로퍼티에 접근할 때마다 해당 메모리 위치로 이동하여 값을 읽거나 쓰게 된다</li>
</ol>

<p>아직도 이해가 안 되었다고? 그러면 예시와 함께 봐보자</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">age</code> 라는 프로퍼티를 갖는 객체를 생성하고 해당 프로퍼티를 초기화하는 간단한 코드</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{};</span> <span class="c1">// 객체 생성</span>

<span class="c1">// 프로퍼티 초기화</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span> <span class="c1">// 값을 할당하고 해당 값은 메모리에 저장됨</span>
</code></pre></div></div>

<p>이 코드에서 <code class="language-plaintext highlighter-rouge">person</code> 객체가 메모리에 할당되고 <code class="language-plaintext highlighter-rouge">age</code>프로퍼티에서는 값 25가 할당되어 메모리에 저장된다</p>

<p>이제 <code class="language-plaintext highlighter-rouge">person.age</code> 를 참조할 때는 해당 메모리 위치로 이동하여 값을 읽게 된다</p>

<ul>
  <li>프로퍼티 어트리뷰트는 자바스크립트 엔진이 관리하는 내부 상태 값인 내부 슬록이다.</li>
  <li>직접 접근할 수 없지만 <code class="language-plaintext highlighter-rouge">Object.getOwnPropertyDescriptor</code> 메서드를 사용하여 간접적으로 확인할 수는 있다</li>
  <li>첫 번째 매개변수에서는 객체의 참조를 전달한다</li>
  <li>두 번째 매개변수에는 프로퍼티 키를 문자열로 전달한다</li>
  <li>이때 <code class="language-plaintext highlighter-rouge">Object.getOwnPropertyDescriptor</code> 메서드는 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 드스크립터 객체를 반환한다.</li>
  <li>존재하지 않거나 상속받은 프로퍼티에 대한 디스크립터를 실행시 undefined가 반환된다</li>
</ul>

<hr />

<h1 id="1631-데이터-프로퍼티와-접근자-프로퍼티">16.3.1 데이터 프로퍼티와 접근자 프로퍼티</h1>

<h2 id="1-데이터-프로퍼티">1. 데이터 프로퍼티</h2>

<p>키와 값으로 구성된 일반적인 프로퍼티</p>

<p>→ 지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티</p>

<h2 id="2-데이터-프로퍼티의-프로퍼티-어트리뷰트">2. 데이터 프로퍼티의 프로퍼티 어트리뷰트</h2>

<h3 id="1-값-value">1. 값 (value)</h3>

<p>: 프로퍼티가 가지고 있는 실제 데이터 값</p>

<ul>
  <li>프로퍼티 키를 통해 프로퍼티에 접근하면 반환되는 값</li>
  <li>프로퍼티 키를 통해 프로퍼티 값을 변경하면 [[VALUE]]에 값을 재할당한다. 이때 프로퍼티가 없으면 프로퍼티를 동적 생성하고 생성된 프로퍼티의 [[VALUE]]값에 저장한다</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">John</span><span class="dl">'</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="2-쓰기-가능-여부-writable">2. 쓰기 가능 여부 (Writable)</h3>

<p>:프로퍼티의 값을 변경할 수 있는지여부를 나타냄</p>

<ul>
  <li>불리언 값을 가짐</li>
  <li>=[[Writable]]의 값이 false 인 경우 [[Value]]의 값을 변경할 수 없는 읽기 전용 프로퍼티가 된다</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">John</span><span class="dl">'</span>
<span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">writable</span><span class="p">:</span> <span class="kc">false</span> <span class="p">});</span>
</code></pre></div></div>

<p>obj.name = ‘Jane’; 에러 발생</p>

<p>→ 읽기 전용 프로퍼티로 설정되었음</p>

<h3 id="3-열거-가능-여부-enumerable">3. 열거 가능 여부 (enumerable)</h3>

<p>:for…in 루프나 Object.keys 등을 사용해 프로퍼티를 열거할 수 있는지 여부를 나타낸다</p>

<ul>
  <li>예도 BOOLEAN 값을 가짐</li>
  <li>[[enumerable]] 의 값이 false인 경우 해당 프로퍼티는 for…in 문이나 Object.keys 메서드 등으로 열거할 수 없다</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">John</span><span class="dl">'</span>
<span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">enumerable</span><span class="p">:</span> <span class="kc">false</span> <span class="p">});</span>
</code></pre></div></div>

<p>for (let key in obj) { console.log(key); } ‘name’이 출력되지 않음</p>

<h3 id="4-설정-가능여부-configurable">4. 설정 가능여부 (configurable)</h3>

<p>:프로퍼티의 속성을 변경하거나 프로퍼티를 삭제할 수 있는지 여부를 나타냄</p>

<ul>
  <li>불리언 갑 ㅅ가짐</li>
  <li>configurable 의 값이 false 인 경우 프로퍼티의 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다.</li>
  <li>단 [[writable]]이 True인 경우 [[value]]의 변경과 [[writable]]을 false로 변경하는 것은 허용한다</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">John</span><span class="dl">'</span>
<span class="p">};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">configurable</span><span class="p">:</span> <span class="kc">false</span> <span class="p">});</span>
</code></pre></div></div>

<p>delete obj.name; 에러 발생, 설정 불가능한 프로퍼티로 설정되었음</p>

<h1 id="1632-접근자-프로퍼티">16.3.2 접근자 프로퍼티</h1>

<p>접근자 프로퍼티는 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티</p>]]></content><author><name>insidepixce</name></author><category term="all" /><category term="react" /><summary type="html"><![CDATA[20230116 : 프로퍼티 어트리뷰트]]></summary></entry><entry><title type="html">20240115 TIL</title><link href="http://localhost:4000/til/all/2024/01/15/TIL.html" rel="alternate" type="text/html" title="20240115 TIL" /><published>2024-01-15T21:27:00+09:00</published><updated>2024-01-15T21:27:00+09:00</updated><id>http://localhost:4000/til/all/2024/01/15/TIL</id><content type="html" xml:base="http://localhost:4000/til/all/2024/01/15/TIL.html"><![CDATA[<h1 id="20230115">20230115</h1>

<p>진도내용: (스코프 - 딥 다이브 인투 JS 14/15WKD)</p>

<h1 id="이해와-관련된-문제-내기">이해와 관련된 문제 내기</h1>

<h3 id="오늘의-문제-리스트">오늘의 문제 리스트</h3>

<h3 id="문제-1"><strong>문제 1:</strong></h3>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">javascriptCopy</span> <span class="nx">code</span>
<span class="kd">function</span> <span class="nx">outer</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">inner</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">inner</span><span class="p">();</span>
<span class="p">}</span>

<span class="nx">outer</span><span class="p">();</span>

</code></pre></div></div>

<p>위의 코드를 실행했을 때, 콘솔에 어떤 값이 출력될까요?</p>

<h3 id="문제-2"><strong>문제 2:</strong></h3>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">javascriptCopy</span> <span class="nx">code</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="nx">bar</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">();</span>

</code></pre></div></div>

<p>위의 코드를 실행했을 때, 콘솔에 어떤 값이 출력될까요?</p>

<h3 id="문제-3"><strong>문제 3:</strong></h3>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">javascriptCopy</span> <span class="nx">code</span>
<span class="kd">function</span> <span class="nx">outer</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">inner</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">inner</span><span class="p">();</span>
<span class="p">}</span>

<span class="nx">outer</span><span class="p">();</span>

</code></pre></div></div>

<p>위의 코드를 실행했을 때, 콘솔에 어떤 값이 출력될까요?</p>

<h3 id="문제-4"><strong>문제 4:</strong></h3>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">javascriptCopy</span> <span class="nx">code</span>
<span class="kd">function</span> <span class="nx">greet</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">greeting</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello</span><span class="dl">"</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">sayHello</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">greeting</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">, </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">!</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">sayHello</span><span class="p">();</span>
<span class="p">}</span>

<span class="nx">greet</span><span class="p">(</span><span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">);</span>

</code></pre></div></div>

<p>위의 코드를 실행했을 때, 콘솔에 어떤 메시지가 출력될까요?</p>

<h3 id="문제-5"><strong>문제 5:</strong></h3>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">javascriptCopy</span> <span class="nx">code</span>
<span class="kd">function</span> <span class="nx">outer</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">inner</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">inner</span><span class="p">();</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">outer</span><span class="p">();</span>

</code></pre></div></div>

<p>위의 코드를 실행했을 때, 콘솔에 어떤 값들이 순서대로 출력될까요?</p>

<blockquote>
  <p>호이스팅은 스코프를 단위로 동작한다. 전역 변수의 호이스팅은 전역 변수의 선언이 전역 스코프의 선두로 끌어올려진것처럼 동작한다. 따라서 전역 변수는 전역 전체에서 유효하다</p>

</blockquote>

<h1 id="암묵적-결합이란">암묵적 결합이란?</h1>

<ul>
  <li>책에서 설명하는 암묵적 결합</li>
</ul>

<aside>
💡 전역 변수를 선언한 의도는 전역, 즉 코드 어디서든 참조하고 할당할 수 있는 변수를 사용하곘다는 것이다. 이는 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용하는 것이다. 변수의 유효 범위가 크면 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다.

</aside>

<p>여기서 설명이 조금 부족하다고 생각해 수진님과 함께 공부해보려 주제를 던졌다</p>

<h3 id="암묵적-결합">암묵적 결합</h3>

<p>형 변환이라고도 불린다. 자바스크립트에서 데이터 타입이 다른 값들이 연산되거나 비교될 때 자동으로 타입이 변환되는 현상을 말한다. 이는 자바스크립트의 동적 타입 특성을 따른다</p>

<ul>
  <li>숫자와 문자열을 더하려고 할 때</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">num</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">10</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">num</span> <span class="o">+</span> <span class="nx">str</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span> <span class="c1">// "510"</span>
</code></pre></div></div>

<p>이 경우에는 숫자와 문자열이 함께 사용되었지만 자바스크립트는 자동으로 숫자를 문자열로 변환하여 문자열 연결이 이루어졌다</p>

<ul>
  <li>비교 연산자</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">num</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">5</span><span class="dl">"</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">num</span> <span class="o">==</span> <span class="nx">str</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<p>비교 연산자가 두 피연산자의 타입을 자동으로 변환하여 일치 여부를 판단하기 때문에 암묵적 결합이 일어났다.</p>

<aside>
💡 이거 신경 안 쓰면 진짜 디버깅 빡세겠는데?

</aside>

<p>→ 명시적인 형 변환을 사용하는 것이 코드를 좀 더 명확하게 만들 수 있다</p>

<p>→ <code class="language-plaintext highlighter-rouge">parseint</code> 나 <code class="language-plaintext highlighter-rouge">number</code> 와 같은 명시적 형 변환 함수를 사용할 수 있음</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">num</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">10</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">num</span> <span class="o">+</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">str</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span> <span class="c1">// 15</span>
</code></pre></div></div>

<p>이런식으로 정확하게 바꿔버리란 이야기다</p>

<ul>
  <li>사용법</li>
</ul>

<p>→ 그냥 냅다 parseInt()이런식으로 해주면 된다. 숫자로 바꾸고 싶으면 Number()이런식으로</p>

<p><a href="https://insidepixce.site/cs/all/2024/01/15/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90.html">배정밀도 부동소수점 정리본 바로가기</a></p>

<h1 id="github-블로그-cname-설정법">GITHUB 블로그 cname 설정법</h1>

<p>오늘 내 블로그가 다운되었다…
왜냐면 내가 커밋하면서 씨네임을 지워버렸기 떄문</p>

<p>걍 CNAME이라는 파일 생성한 다음 그 안에 WWW로 시작하는 주소 넣어주면 된다. 그렇게 어렵지 않음. dns 설정 다시 안 만져두 됨!</p>]]></content><author><name>insidepixce</name></author><category term="all" /><category term="react" /><summary type="html"><![CDATA[20230115]]></summary></entry><entry><title type="html">배정밀도 64비트 부동소수점</title><link href="http://localhost:4000/cs/all/2024/01/15/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90.html" rel="alternate" type="text/html" title="배정밀도 64비트 부동소수점" /><published>2024-01-15T16:42:00+09:00</published><updated>2024-01-15T16:42:00+09:00</updated><id>http://localhost:4000/cs/all/2024/01/15/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90</id><content type="html" xml:base="http://localhost:4000/cs/all/2024/01/15/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90.html"><![CDATA[<p>책을 보다가 의문점이 생겼다. ECMAScript에 따르면,  숫자 타입의 값은 배정밀도 64비트 부동소수점 형식을 따른다고 하는데, 이 배정밀도 64비트 부동소수점 형식이 무엇인가?</p>

<p>이는 모든 수를 실수로 처리하며, 정수만 표현하기 위해 데이터 타입이 별도로 존재하지 않는다는 말이다. 이게 무슨 말인지 헷갈린다면, 다음 실습을 통해 한번 보도록 하자.</p>

<ul>
  <li>어, 왜 0.3 그대로 나오지 않지?</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="p">(</span><span class="mf">0.1</span><span class="o">+</span><span class="mf">0.2</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="p">(</span><span class="mf">0.1</span><span class="o">+</span><span class="mf">0.2</span> <span class="o">==</span> <span class="mf">0.3</span><span class="p">);</span>
</code></pre></div></div>

<p>원래같으면 0.1 + 0.2 = 0.3 이라고 예측했을 것이다. 하지만, 우리의 자바스크립트 친구는 정말 웃기게도 다음과 같은 값을 내뱉는다.</p>

<p><img src="https://velog.velcdn.com/images/insidepixce/post/088f1bd5-5a1d-4094-9d8a-f9b185ef5c9c/image.png" alt="" /></p>

<p>자바스크립트는 7가지의 데이터 타입을 가지고 있고, 이는 원시 타입, 객체 타입으로 구분된다. 이떄, 숫자 타입은 정수, 부동 소수점, 그리고 NAN(Not A Number)과 infinirty 등을 표현할 수 있다. 정수는 부호 있는 정수와 부호 없는 정수로 나뉘며 , 부동소수점은 실수 값을 표현한다.</p>

<p>부동소수점은 컴퓨터에서 실수를 표현하는 방식 중 하나이다. 부동소수점은 소수점을 고정된 위치에 두는 대신, 가수부와 지수부로 숫자를 표현한다</p>

<p>가수부는 실제 숫자의 유효 숫자를 나타내는 부분이며, 지수부는 소수점의 위치를 표현하는 부분이다. 이 두 부분은 함께 사용되어 실수 값을 나타낸다.</p>

<p>부동소수점은 소수점을 가지는 숫자를 나타낼 때 사용되는데, 자바스크립트에서 이는 64비트 (double-precision) 형식으로 표현되며, IEEE 754 표준에 따라 정의된다.</p>

<aside>
💡  IEEE 754 : 부동소수점 숫자를 표현하기 위한 국제 표준

</aside>

<p>부동소수점은 가수부와 지수부로 나누어진다.</p>

<p>예를 들어 0,004의 경우, 소수점 이하 자릿수가 있는 숫자이므로 부동소수점으로 표현된다.</p>

<p>여기서 정수 부분은 0이고, 소수 부분은 004이다. 소수 부분은 이진 소수로 표현되는데, 정확한 값은 0.004의 이진 표현이 된다. 주의할 점은, 0.004와 같은 소수를 정확하게 표현하려면 부동소수점 형식의 제약 사항을 고려해야 한다. 이진 부동소수점 형식에서는 모든 소수를 정확하게 표현할 수 없기에 위와 같은 에러가 발생하는 것이다.</p>

<p>일반적으로 많은 경우에 잘 작동하지만, 떄로는 정확한 결과를 보장하지 못하는 반올림 오차가 발생하기도 한다.</p>

<ul>
  <li>부동소수점을 사용하기 떄문에 반올림 오차가 생기는 건 알겠어! 근데 어떤 과정으로 그렇게 되는 건데?</li>
</ul>

<p>→ 부동소수점 숫자를 이진 부동소수점으로 표현하는 과정에서 근사값이 사용되기 떄문이다.</p>

<p>1/3을 십진수로 정확히 표현하려면 0.33333…과 같이 무한 소수로 표현해야 한다. 이를 피하기 위해, 반올림 값을 가지는 것이다.</p>

<p>아까 들었던 예시 코드를 보면서 어떤 과정을 거치는지 알아보자.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="p">(</span><span class="mf">0.1</span><span class="o">+</span><span class="mf">0.2</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="p">(</span><span class="mf">0.1</span><span class="o">+</span><span class="mf">0.2</span> <span class="o">==</span> <span class="mf">0.3</span><span class="p">);</span>
</code></pre></div></div>

<ol>
  <li>0.1을 이진 부동소수점으로 변환 :</li>
</ol>

<p>0.0001100110011001100110011001100110011001100110011…</p>

<p>소수 부분인 0.1을 이진 분수로 변환하면 무한 소수가 된다.</p>

<p>그러나 64비트 double-precision 형식에서는 가수 부분에만 53비트가 할당되므로, 가장 가까운 근사값을 사용한다 → 더욱 공부해볼 주제. 나도 확실히 이해하지 못했다.</p>

<ol>
  <li>0.2을 이진 부동소수점으로 변환:
    <ul>
      <li>0.0011001100110011001100110011001100110011001100110…</li>
      <li>마찬가지로, 소수 부분인 0.2를 이진 분수로 변환하면 무한 소수가 된다</li>
      <li>가수 부분은 0.0011001100110011001100110011001100110011001100110…과 같은 근사값을 사용한다</li>
    </ul>
  </li>
  <li>두 숫자를 더함:
    <ul>
      <li>0.0001100110011001100110011001100110011001100110011… (0.1의 근사값)</li>
      <li>0.0011001100110011001100110011001100110011001100110… (0.2의 근사값)</li>
    </ul>
  </li>
</ol>

<p>→0.0100110011001100110011001100110011001100110011001…</p>

<p>결과로 나온 0.30000000000000004는 이진 부동소수점으로 근사된 값이다. 이 값은 정확한 0.3이 아니며, 반올림 오차가 발생한 것이다..</p>

<p>IEEE 754 표준에서는 부호(S, sign), 지수(E, exponent), 가수(M, mantissa) 3개의 비트 그룹으로 숫자를 표한다. 각각의 패턴은 다음의 형식에 따라 수를 표현한다.</p>

<p>Value =(−1)×1.M×{2^(E−bias)} (1)</p>

<p>S는 부호를 나타내고. S=0은 양수를, S=1은 음수를 나타내. M은 가수를 나타내며, 1.M으로 처리하여 모든 값을 얻는다. 이는 각 부동소수점 숫자에 대한 가수 비트 패턴을 고유하게 만들어준다. E는 지수를 나타내며, excess or biased 인코딩 규칙을 채택한다. 만약 지수 E를 표현하기 위해 e 비트가 사용되었다면, (2^(e−1)−bias)이 그 지수에 대한 2의 보수값에 더해져서 excess representation(초과 표현)을 나타낸다.</p>

<p>부동소수점에서는 정규화된 표현을 만족하는 가수는 1.XX 형태이므로, 부동소수점을 표현할 때 ‘1’을 생략할 수 있다. 이러한 제한을 만족하는 수를 정규화된 수(normalized number)라고 한다.</p>

<h2 id="그래서">그래서?</h2>

<p>이에 대한 명확한 이해는 특히 큰 수의 합산이 필요한 수치 알고리즘에서 중요하다. 행렬 곱셈과 같은 연산은 여러 입력 행렬 요소들의 곱을 합산하는 내적 연산을 필요로 한다. 이론적으로, 덧셈의 결합법칙에 따라 이 값들의 합산 순서는 결과에 영향을 미치지 않아야 하지만, 실제로는 부동 소수점의 정밀도 부족으로 인해 순서가 결과의 정확성에 영향을 미칠 수 있다.</p>

<p>5-비트 표현을 사용하여 4개의 수를 더하는 예를 생각해 보자. 만약 이러한 숫자들이 순차적으로 더해진다면, 중간 과정에서 일부 수치가 반올림되어 결과에 영향을 미치게 된다. 이 경우, 순차적으로 더해진 결과는 1.01×2^1이 된다.</p>

<p>반면에, 이 덧셈이 병렬 알고리즘에서 수행되면 결과는 다르게 나온다. 각 쌍의 합계는 병렬로 계산되고, 마지막에 두 합계가 더해진다. 하지만 이 결과는 순차적인 덧셈과 다르게 나온다. 이는 병렬 연산에서의 부동 소수점 연산의 정밀도가 결과에 영향을 미치기 때문이다. 이런 현상은 부동 소수점 연산의 복잡성을 잘 보여주는 예이다.</p>

<p>이러한 문제를 최소화하는 방법 중 하나는 Reduction 연산을 수행하기 전에 데이터를 정렬하는 것이다. 즉, 값을 오름차순으로 정렬하여 합산할 때, 서로 가까운 값들끼리 더하는 것이다. 이는 병렬 알고리즘에서 특히 유용하며, 이로 인해 동일한 그룹 내에서는 덧셈의 결과가 더욱 정확해진다.</p>

<p>예를 들어, 앞서 언급한 4개의 숫자를 오름차순으로 정렬하면 다음과 같이 된다: 1.00×2^(-2), 1.00×2^(-2), 1.00×2^0, 1.00×2^0. 이제 이 값들을 순차적으로 더하면, 같은 그룹에 있는 값들은 비슷한 크기를 가지므로 정확도가 향상된다</p>

<p>따라서 병렬 수치 알고리즘에서는 입력 데이터를 미리 정렬하는 것이 일반적이다. 이렇게 함으로써 병렬 연산에서 발생할 수 있는 부동 소수점 오류를 최소화하고, 결과의 정확성을 높일 수 있다.</p>

<p>이런 방식은 부동 소수점 연산의 정확도 문제를 완전히 해결할 수는 없지만, 실제 애플리케이션에서는 효과적인 해결책을 제공할 수 있다. 부동 소수점 연산을 수행할 때는 항상 정밀도 오류를 고려하고, 가능한 경우 데이터를 미리 정렬하는 것이 좋다.</p>

<p>해보면, 결과는 1.00×2^1이 된다. 이것은 병렬 덧셈의 결과와 일치한다.</p>

<p>그럼에도 불구하고, 이런 방법으로도 오차를 완전히 제거할 수는 없다. 이는 부동소수점 연산이 항상 어떤 정밀도로 제한되기 때문이다. 따라서, 연산의 결과는 항상 정확하지 않을 수 있다는 것을 항상 숙지하고 있어야 할 것 같다.</p>

<p>부동소수점의 불완전함에 대한 완전한 이해는 데이터 과학자, 프로그래머, 엔지니어 등 많은 분야의 전문가들에게 매우 중요하다. 이는 과학적, 엔지니어링 계산의 정확성을 보장하는데 필수적이며, 이는 종종 연구 결과의 정확성과 신뢰성에 직접적인 영향을 미친다.</p>

<p>참고자료 https://junstar92.tistory.com/253</p>]]></content><author><name>insidepixce</name></author><category term="all" /><category term="react" /><summary type="html"><![CDATA[책을 보다가 의문점이 생겼다. ECMAScript에 따르면, 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식을 따른다고 하는데, 이 배정밀도 64비트 부동소수점 형식이 무엇인가?]]></summary></entry><entry><title type="html">변수로 시작해 스와핑기법까지</title><link href="http://localhost:4000/c/s/all/2024/01/12/%EB%B3%80%EC%88%98%EC%97%90%EC%84%9C%EC%8A%A4%EC%99%80%ED%95%91.html" rel="alternate" type="text/html" title="변수로 시작해 스와핑기법까지" /><published>2024-01-12T12:00:00+09:00</published><updated>2024-01-12T12:00:00+09:00</updated><id>http://localhost:4000/c/s/all/2024/01/12/%EB%B3%80%EC%88%98%EC%97%90%EC%84%9C%EC%8A%A4%EC%99%80%ED%95%91</id><content type="html" xml:base="http://localhost:4000/c/s/all/2024/01/12/%EB%B3%80%EC%88%98%EC%97%90%EC%84%9C%EC%8A%A4%EC%99%80%ED%95%91.html"><![CDATA[<p>변수,,변수</p>

<h1 id="변수란-무엇인가">💁🏻 변수란 무엇인가</h1>
<p>우리가 10+20을 하면 10과 20, 그리고 + 를 기억하여 그 결과를 계산한다.</p>

<p>→ 이는 컴퓨터도 마찬가지이다.</p>

<p>→ 10은 리터럴 + 는 연산자이다. 이들을 모두 알아서 해석한다.</p>

<p>그럼 10과 20은 어디에 저장하는가? 이들은 모두 메모리에 저장된다.</p>

<p>각 메모리에는 메모리 주소가 있다</p>

<p>→ 이 숫자들은 모두 이진으로 저장된다.</p>

<p>메모리 주소에 저장된 이 친구들을 불러내야 하는데, 직접 메모리 주소를 사용하면 위험도가 있다.</p>

<p>→ 메모리 주소에 직접 접근하다가 시스템의 메모리에 잘못 접근하면 엄청난 문제가 생길 수 있기 때문이다.</p>

<p>⇒ 그래서 자바스크립트는 메모리 주소에 직접적으로 접근하지 못한다.</p>

<p>🤔 그렇다면 우리는 한 개의 값으로 연산을 할 때마다 그 값을 새로 입력해줘야 하는 것인가?</p>

<h3 id="그래서-변수라는-개념이-나온-것이다-">😃 그래서 변수라는 개념이 나온 것이다 !</h3>

<p>내가 만약 10이라는 값을 <strong>할당</strong> 한다고 하자</p>

<p>💡 할당이란 값을 변수에 넣는 것이다</p>

<p>이때 10은 고유한 메모리에 들어갈 것이다</p>

<p>이때 각 메모리 주소를 전부 입력할 수 없으니 (접근이 제한되어 있으니) 우리는 메모리 주소에 이름을 붙인다. 이를 변수라고 한다.</p>

<hr />

<h1 id="그렇다면-질문이-있는데">🤔그렇다면 질문이 있는데…</h1>

<h2 id="️변수와-물리적-주소-가상-주소까지-공부의-시작이였던-이-질문">🤷🏻‍♂️변수와 물리적 주소 가상 주소까지… 공부의 시작이였던 이 질문</h2>

<p>👩🏻‍💼: A라는 변수에 10이라는 값을 할당하는 프로그램을 작성하고 프로그램을 실행 후 완전히 종료하고 다시 실행했다. 그렇다면 10이라 값은 다시 한 번 다른 메모리 자리에 할당되고 이 변수의 이름이 A가 되는 것인가?</p>

<p>그렇다면 이전에 할당된 메모리는 쓰지 않을 텐데, 어떻게 관리하는 것인가?</p>

<p>⏹  : 프로그램을 실행하면 컴퓨터는 해당 프로그램을 메모리에 로드하고 실행하는데, 이 과정에서 변수와 데이터는 메모리에 할당된다.</p>

<p>변수 A에 10이라는 값을 할당하는 경우, 10이라는 데이터가 메모리에 저장되고 해당 메모리 위치에 변수 이름인 A가 매핑된다.</p>

<p>프로그램을 실행하고 완전히 종료한 후 다시 실행하면, 기본적으로 운영체제는 새로운 프로세스로 실행을 시작한다. 이전 실행에서 사용된 메모리는 더이상 사용하지 않는다.</p>

<h2 id="️이-메모리는-어떻게-처리하냐라고-묻는다면">🤷🏻‍♂️이 메모리는 어떻게 처리하냐라고 묻는다면…?</h2>

<p>운영체제는 프로세스의 실행과 종료를 관리하고 각 프로세스가 필요로 하는 메모리를 할당하고 회수하는 작업이 수행된다.</p>

<p>프로그램이 종료되면 해당 프로세스에 사용된 메모리는 운영체제에 의해 회수되어 재사용 가능한 상태가 된다. 이렇게 함으로써 메모리 사용을 좀 더 효율적으로 관리하고 충돌이나 <strong>메모리 누수</strong>와 같은 문제를 방지한다.</p>

<h1 id="메모리-누수란">메모리 누수란?</h1>

<p>💡 메모리 누수란? : 응용 프로그램에서 데이터를 메모리에 저장했다가, 필요없어졌을때 적절하게 제거되지 않는 것. ‘메모리 릭 (Memory leak)이라고도 한다</p>

<ul>
  <li>메모리에 데이터가 남아 있어도 운영 체제가 의도한 것이라면 데이터 누수가 아니다</li>
  <li>windows vista 이후의 운영체제 및 안드로이드에선 옛날만큼 메모리 공간이 빡빡하지 않다는 것을 감안하여 종료시킨 프로그램을 일부러 메모리 상에 남겨두기도 한다</li>
</ul>

<p>→ 사용자가 다시 실행시켰을때 더 빠르게 응답할 수 있다.</p>

<p>→ 사용자가 다른 작업을 하다가 다시 메모리가 부족해지면 알아서 정리해준다.</p>

<p>??? 엥? 저번에 들었던 가비지 컬렉션의 개념이 생각나. 그 개념은 언어 자체가 메모리를 관리하는 거였는데??</p>

<h2 id="운영-체제의-메모리를-관리-vs-가비지-컬렉션">운영 체제의 메모리를 관리 VS 가비지 컬렉션</h2>

<h3 id="운영-체제가-메모리를-관리하는-것">🌐 운영 체제가 메모리를 관리하는 것</h3>

<ul>
  <li>운영 체제는 프로세스가 메모리를 요청하면 해당 메모리를 할당하고 , 프로세스가 종료되면 메모리를 회수하여 재사용 가능한 상태로 만든다</li>
  <li>프로세스들 간의 메모리 공간을 분리하여 충돌이나 오류를 방지하고, 시스템의 안정성을 유지한다</li>
</ul>

<h3 id="가비지-컬렉션">🗑 가비지 컬렉션</h3>

<ul>
  <li>프로그래밍 언어의 <strong>런타임 환경</strong>에서 담당하는 기능으로, 메모리를 동적으로 관리하는 상황에서 발생하는 메모리 누수를 방지하고 자동으로 더 이상 사용되지 않는 메모리를 회수하는 역할을 함</li>
  <li>더이상 필요없는 변수, 객체들을 식별하고 메모리를 자동으로 회수하여 재사용 가능한 상태로 만들어준다.</li>
  <li>JAVA, C#, PYTHON 등의 언어에서 가비지 컬렉션을 지원하며 언어의 런타임 환경이 가비지 컬렉션을 담당한다</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>운영 체제는 컴퓨터 자원을 관리함
프로세스들의 실행과 메모리 할당/ 회수 담당

가비지 컬렉션은 런타임에서 메모리 관리를 담당
사용하지 않는 것을 식별하고 자동으로 회수
</code></pre></div></div>

<p>사실 아직도 그 둘의 차이를 잘 이해를 못 했었다.</p>

<p>그래서 예시를 들어서 공부해보기로 했다</p>

<h1 id="이렇게-가정해보자">💡 이렇게 가정해보자</h1>

<ol>
  <li>VS CODE를 실행한다</li>
  <li>A = 10이라는 값을 할당하는 코드를 쓴다</li>
  <li>코드를 실행한다</li>
  <li>종료한다</li>
  <li>VS CODE를 닫는다</li>
</ol>

<ul>
  <li>VS CODE를 실행한다</li>
</ul>

<p>→ 운영 체제는 VScode 프로세스에 필요한 메모리를 할당하고, 사용할 수 있도록 확보한다.</p>

<h2 id="-이때-좀-더-자세한-과정을-보자면">😺 : 이때 좀 더 자세한 과정을 보자면…</h2>

<p>→ 가상 주소와 물리 주소에 대한 설명은 이 과정을 모두 적고 공부해보았다.</p>

<h3 id="1-프로세스-생성">1. 프로세스 생성</h3>

<ul>
  <li>VSCODE를 실행하면 운영 체제는 새로운 프로세스를 생성한다.</li>
  <li>프로세스는 실행 중인 프로그램을 나타내며, 자신만의 독립된 메모리 공간을 가지고 실행한다</li>
</ul>

<h3 id="2-가상-주소-공간-할당">2. 가상 주소 공간 할당</h3>

<ul>
  <li>운영 체제는 VS CODE 프로세스에게 <strong>가상 주소 공간</strong>을 할당한다. 가상 주소 공간은 각 프로세스가 독립적으로 사용하는 가상의 메모리 공간을 의미한다.</li>
  <li>이 가상 주소 공간은 실제 물리적 메모리와는 분리되어 있으며, 프로세스가 사용하는 주소들은 <strong>가상 주소</strong>로 매핑되어 실제 메모리에 할당된다.</li>
</ul>

<h3 id="3-물리적-메모리-할당">3. 물리적 메모리 할당</h3>

<ul>
  <li>가상 주소 공간에 할당된 메모리는 실제 물리적 메모리에 매핑되어야 한다.</li>
  <li>이때 운영 체제는 VSCODE 프로세스가 필요로 하는 물리적 메모리를 확보한다.</li>
  <li>즉 , 운영 체제는 VSCODE에 필요한 메모리 공간을 실제 물리적 메모리에 할당하여 사용할 수 있도록 한다.</li>
</ul>

<h3 id="4-메모리-보호">4. 메모리 보호</h3>

<ul>
  <li>운영 체제는 각 프로세스들간의 메모리 공간을 보호하기 위해 메모리 보호 기법을 사용한다.</li>
  <li>각 프로세스는 자신의 주소 공간에서만 접근이 가능하고, 다른 프로세스의 주소 공간에는 접근할 수 없도록 제한된다.</li>
</ul>

<h3 id="5-프로세스-실행">5. 프로세스 실행</h3>

<ul>
  <li>VSCODE 프로세스가 메모리를 할당받고 초기화되면, 운영 체제는 해당 프로세스를 실행시킨다.</li>
  <li>이제 VSCODE는 자신의 가상 주소 공간 내에서 실행되며, 필요한 데이터와 코드가 메모리에 로드되어 사용된다</li>
</ul>

<h3 id="7-변수-쓰기-가비지-컬렉션">7. 변수 쓰기 (가비지 컬렉션)</h3>

<ul>
  <li>자바스크립트의 경우</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// main.js
let A = 10;
console.log(A);
</code></pre></div></div>

<p>변수 A에 10이 할당되고, 콘솔에 10이 출력된다. 코드 실행이 완료되면 NODE.JS가 사용한 메모리는 운영 체제에 의 해 회수된다.</p>

<p>JS는 가비지 컬렉션을 내장해 이때 가비지 컬렉터에 의해 식별되고 자동으로 회수된다.</p>

<ul>
  <li>C언어의 경우</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;

int main() {
    int A = 10;
    printf("%d\n", A);
    return 0;
}
</code></pre></div></div>

<p>코드 실행이 완료되면 C프로그램이 사용한 메모리는 운영 체제에 의해 회수된다. C 언어는 메모리 할당과 해제를 개발자가 직접 관리해야 하므로, 메모리 누수가 발생하지 않도록 메모리 해제 코드를 작성해야 한다</p>

<h3 id="8-프로세스-종료">8. 프로세스 종료:</h3>

<ul>
  <li>VSCODE 실행이 끝나고 VSCODE를 종료하면, 운영 체제는 해당 프로세스가 사용한 메모리를 회수한다.</li>
  <li>프로세스가 종료되면 할당된 가상 주소 공간과 물리적 메모리는 다른 프로세스가 사용할 수 있도록 해제된다.</li>
  <li>이렇게 함으로써 VSCODE의 실행에 사용된 메모리가 운영 체제에 의해 회수되고 재사용 가능한 상태가 된다</li>
</ul>

<h1 id="가상-주소란-무엇인가">💁🏻  <strong>가상 주소</strong> 란 무엇인가?</h1>

<p>가상 메모리란? 프로세스는 가상 주소를 사용하고, 데이터를 사용할때 물리 주소로 변환해준다는 것이다.</p>

<p>가상 주소 : 프로세스가 참조하는 주소</p>

<p>물리 주소 : 실제 메모리 주</p>

<p>MMU : CPU에 코드 실행시, 가상 주소 메모리 접근이 필요할때, 해당 주소를 물리 주소 값으로 변환시켜주는 하드웨어 장치.</p>

<h2 id="그럼-가상-주소-왜-쓰는데">🤓 그럼 가상 주소 왜 쓰는데?</h2>

<ol>
  <li>프로세스 독립성 : 각 프로세스는 각각의 가상 주소 공간을가지고 있다. 이로 인해 프로세스는 서로의 주소 공간에 영향을 미치지 않고 독립적으로 실행될 수 있다.</li>
</ol>

<p>→ 따라서 하나의 프로세스에서 발생한 오류나 메모리 접근 오류가 다른 포르세스에 영향을 미치지 않아 안정성이 향상된다</p>

<h2 id="️여기서-발생한-의문">🤷🏻‍♂️ 여기서 발생한 의문!</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🤔그냥 물리적인 주소를 각각 다르게 주면 되는 거 아니야?
</code></pre></div></div>

<p>→ 가상 주소는 논리적인 주소이다.</p>

<p>→ 가상 주소를 사용하면 여러 프로세스들이 메모리를 공유할 수 있다. 물리적 메모리의 용량보다 더 많은 가상 주소를 가진 프로세스들이 동시에 실행될 수 있으며, 가상 주소를 물리적 주소로 매핑함으로써 메모리를 효율적으로 사용할 수 있다.</p>

<p>🤬 이게 뭔 소리냐?</p>

<p>아니, 가상 주소는 프로세스가 각각의 가상 주소 공간을 가지며 서로의 공간에 영향을 미치지 않고 독립적으로 사용할 수 있게 한다고 했잖아… 그런데 메모리를 공유한다는 건 무슨 소리야 도대체?</p>

<h2 id="그럼-한번-예시를-들어보자">📤 그럼 한번 예시를 들어보자</h2>

<p>프로세스 A와 B가 있다. 이들은 물리적 메모리의 용량보다 크다. 이때 가상 주소로 해결하는 방법을 알아보자.</p>

<p>→ 가상 주소를 사용하여 메모리를 효율적으로 관리하기 위해서 운영 체제는 물리적 메모리를 효율적으로 활용해야 한다.</p>

<h3 id="1-가상-주소-공간-할당">1. 가상 주소 공간 할당:</h3>

<p>운영 체제는 각 프로세스 A와 B에게 가상 주소 공간을 할당한다.</p>

<p>각 프로세스는 <strong>자신만의</strong> 가상 주소 공간을 갖게 된다</p>

<h3 id="2-물리적-메모리-공간-관리-">2. 물리적 메모리 공간 관리 :</h3>

<p>물리적 메모리에는 실제 데이터와 프로그램 코드가 저장되므로 모든 가상 주소를 물리적 주소로 직접 할당할 수는 없다.</p>

<h3 id="3-페이지-기반-가상-메모리-관리">3. 페이지 기반 가상 메모리 관리:</h3>

<p>대부분의 운영 체제는 페이지 기반의 가상 메모리 관리를 사용하여 가상 주소와 물리적 주소 간의 매핑을 수행한다. 가상 메모리를 작은 크기의 페이지로 나누고, 물리적 메모리도 동일한 크기의 페이지로 나눈다.</p>

<h3 id="4-페이지-테이블">4. 페이지 테이블:</h3>

<p>각 프로세스마다 페이지 테이블이라는 자료구조를 유지한다.</p>

<ul>
  <li><strong>페이지 테이블이란</strong> 페이지 테이블은 가상 주소의 각 페이지가 실제 물리적 메모리의 어떤 페이지와 매핑되는지를 기록한다. 프로세스가 가상 주소를 참조하면 페이지 테이블을 사용하여 해당 가상 주소를 물리적 주소로 변환한다
    <ul>
      <li>페이지 번호(Page Number): 가상 주소에서 페이지 번호를 식별하는 부분</li>
      <li>페이지 프레임 번호(Page Frame Number): 물리적 메모리에서 페이지가 위치하는 프레임 번호를 기록</li>
      <li>기타 제어 비트(Control Bits): 페이지에 대한 다양한 제어 정보를 포함한다 예를 들어 해당 페이지가 물리적 메모리에 들어가졌었는지의 여부, 수정 가능한 페이지인지 등을 나타낼 수 있따.</li>
    </ul>
  </li>
</ul>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlKzlK%2Fbtsp6pVGHt4%2FXQMomZiZhorHEcz72zslb1%2Fimg.png" alt="이미지" /></p>

<p>가상 주소에 의해 주소가 지정된 페이지와 물리 메모리의 페이지 간의 관계 (단순한 주소 공간 스킴에서) 물리 메모리는 수많은 프로세스에 속하는 페이지를 포함할 수 있다. 거의 사용하지 않을 경우 페이지는 디스크에 보관할 수 있으며, 물리 메모리가 꽉차 있으면 위의 그림처럼 일부 페이지는 물리 메모리에 위치하지 않는다.</p>

<p>(이미지 출처: 위키백과)</p>

<h3 id="5-페이지-폴트">5. 페이지 폴트</h3>

<p>프로세스가 처음으로 해당 페이지를 접근할 때 물리적 메모리에 해당 페이지가 없는 경우 페이지 폴트가 발생</p>

<ul>
  <li>페이지 폴트란? → 즉, 프로세스가 요청한 페이지가 현재 물리적 메모리에 올라와 있지 않을 때 발생 → 이 경우 운영체제는 해당 페이지를 물리적 메모리로 가져와야 함
    <ul>
      <li>프로세스가 페이지 폴트를 발생시키면, 운영 체제는 먼저 해당 페이지가 디스크에 저장되어 있는지 확인한다</li>
      <li>만약 해당 페이지가 디스크에 저장되어 있다면, 디스크에서 가져온다</li>
      <li>가져온 페이지를 물리적 메모리에 적재하고, 페이지 테이블을 업데이트하여 해당 가상 주소가 새로운 물리적 주소와 매핑되도록 한다</li>
      <li>이후에 다시 참조해보면 데이터나 코드에 접근할 수 있다</li>
    </ul>
  </li>
</ul>

<h3 id="6-페이지-교체">6. 페이지 교체</h3>

<p>물리적 메모리 공간이 가득 찬 경우, 운영 체제는 페이지 교체 알고리즘을 사용하여 더 이상 사용되지 않는 페이지를 디스크로 옮기고 새로운 페이지를 메모리에 로드한다.</p>

<p>→ 이렇게 함으로써 물리적 메모리에 가상 주소 공간을 연결할 수 있다</p>

<h3 id="7-다중-프로그래밍과-스와핑">7. 다중 프로그래밍과 스와핑</h3>

<p>다중 프로그래밍 환경에서는 여러 개의 프로세스가 동시에 실행된다. 만약 모든 프로세스가 동시에 물리적 메모리에 올라갈 수 없는 경우, 운영 체제는 스와핑 기법을 사용하여 현재 실행 중인 프로세스의 일부를 디스크로 내보내고, 새로운 프로세스를 메모리에 로드함으로써 다른 프로세스로 전환한다.</p>

<hr />

<h1 id="후기">후기</h1>

<p>변수가 어디에 할당되는지 찾다가 많은 것을 알게 된 공부였다.<br />
실제 메모리보다 더 쓰는 방식으로 저러한 방식을 채택한 개발자들이 정말 대단해 보였고 나 또한 저렇게 시대를 이끌어가는 개발자가 되고 싶었다.</p>]]></content><author><name>insidepixce</name></author><category term="all" /><category term="react" /><summary type="html"><![CDATA[변수,,변수]]></summary></entry><entry><title type="html">암호화 키 오류</title><link href="http://localhost:4000/react/all/2024/01/12/itsone.html" rel="alternate" type="text/html" title="암호화 키 오류" /><published>2024-01-12T12:00:00+09:00</published><updated>2024-01-12T12:00:00+09:00</updated><id>http://localhost:4000/react/all/2024/01/12/itsone</id><content type="html" xml:base="http://localhost:4000/react/all/2024/01/12/itsone.html"><![CDATA[<p>아침부터 에러나는건 우리 예의가 아니지 </p>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/7kap/image/X7sAg-E45Tgfn5DhO46R2O1wN3Q.jpg" alt="예시 이미지" /></p>

<p>리엑트 네이티브로 개발하는 앱에서 결제 기능을 추가하는 것은 꽤나 일반적인 작업 중 하나인데 오늘 진짜 특이한 경험을 했다.</p>

<p>하지마 이 개새끼야 ~!!!!!</p>

<h2 id="1-문제-발견">1. 문제 발견</h2>

<p>결제 프로세스를 시작하자 마자 “암호화 키가 일치하지 않는다”라는 에러가 발생했다. 테스트해보니 사용자에게도 노출될 코드였다.</p>

<h2 id="2-초기분석">2. 초기분석</h2>

<p>처음에는서버측에서 보내는 암호화 키와 클라이언트에서사용하는 암호화 키가 다르다고 생각했다. 서버 코드를 열고 관련 키 값들을 점검했다. 근데,,, 어,,, 둘다 암호화 키가 같다…?</p>

<h2 id="3-디버깅-시작">3. 디버깅 시작</h2>

<p>결제과정 코드를 꼼꼼히 살펴보았다. 하는 도중에 내가 이래서 js를 좋아한다는 걸 깨달았다. 읽기가 너무 편해</p>

<p>아무튼 암호화 모듈을 살펴보았는데, 네이티브 모듈로 구현되어있었다. js코드와 네이티브 코드간의 통신이 피요했다</p>

<h2 id="4-문제의-원인을-봤다">4. 문제의 원인을 봤다.</h2>

<p>암호화를 담당하는 부분의 로직을 보고 보고 보고 또 봤다. 아니 세상에. 암호화 키를 생성하고 저장하는 로직에 큰 문제점이 있었다. 암호화 키는 앱이 설치될때마다 생성되어야 하는데 이 키가 여러번 생성되어서 중복되는 문제가 있었다. 서버에서는 암호화된 데이터를 복호화할수 없었고, 이러한 문제가 생겨버린 것이다.</p>

<p>실제 코드는 아니지만 재현해보자면 이런 구조였다</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { NativeModules } from 'react-native';

const { EncryptionModule } = NativeModules;

class PaymentService {
  constructor() {
    this.encryptionKey = this.generateEncryptionKey();
  }

  generateEncryptionKey() {
    return EncryptionModule.generateKey();
  }

  makePayment(data) {
    const encryptedData = EncryptionModule.encrypt(data, this.encryptionKey);
    // ... 결제 로직
  }
}
</code></pre></div></div>

<p>‘PaymentService’클래스가 생성될때마다 ‘generateEncryptionKey’함수가 호출되어 암호화 키가 생성된다. 다른 모듈이나 컴포넌트에서 ‘PaymentService’를 여러번 초기화할 경우, 다양한 키 값들이 생성되었고, 그게 문제였던 것이다 !</p>

<p>ㅇ아ㅏ… 이마 한 번 짚고 다시 달린다.</p>

<ol>
  <li>키 생성 로직 개선 : 암호화 키 생성 로직을 수정해 키가 한번만 생성되도록 만든다</li>
  <li>데이터베이스 키 저장 : 생성된 키를 로컬 데이터베이스에 저장하고 앱이 실행될때마다 해당 키를 불러와 사용하도록 로직을 바꿨다.</li>
  <li>키 동기화 : 서버와의 통신 시 생성된 키를 함께 전송하여 서버도 동일한 키를 사용하도록 했다.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { NativeModules } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';

const { EncryptionModule } = NativeModules;

class PaymentService {
  constructor() {
    this.loadEncryptionKey();
  }

  async loadEncryptionKey() {
    let key = await AsyncStorage.getItem('encryptionKey');
    if (!key) {
      key = EncryptionModule.generateKey();
      await AsyncStorage.setItem('encryptionKey', key);
    }
    this.encryptionKey = key;
  }

  makePayment(data) {
    const encryptedData = EncryptionModule.encrypt(data, this.encryptionKey);
    // ... 결제 로직
  }
}
</code></pre></div></div>

<p>대충 이런 구조로 수정해주었다</p>

<ul>
  <li>Singleton Pattern : ‘PaymentService’를 싱글톤 패턴으로 구현하여 인스턴스가 하나만 생성되도록하였다. 이렇게 하면 암호화 키도 한 번만 생성된다</li>
  <li>AsyncStorage : 생성된 암호화 키를 로컬에 저장하여 앱이 재시작될때마다 동일한 키를 사용하도록 했다. 이를 위해 @react-native-async-storage/async-storage 라이브러리를 사용했다</li>
  <li>초기화 로직 변경 : ‘PaymentService’의 초기화 로직에서 암호화 키를 생성하는 대신, 로컬 데이터베이스에서 불러와 사용하도록 변경해주었다. 키가 없을 경우에만 새로 생성했다.</li>
  <li>아마도 로컬로 저장하는것도 방법인 것 같다. 생성된 암호화 키는 로컬 데이터베이스, 예를 들면 AsyncStorage</li>
</ul>

<p>암호화는 데이터 보호를 위해 꼭 필요한 과정이다. 특히 결제나 인증과 같은 중요한 트랜젝션에서는 데이터의 무결성을 보장하기 위해 암호화가 필수이다. 리엑트 네이티브에서도 이러한 암호하 처리가 필요하고, 암호화 키를 안전하게 관리하는 것 또한 중요한데,  진짜 나 정신차리자 .</p>]]></content><author><name>insidepixce</name></author><category term="all" /><category term="react" /><summary type="html"><![CDATA[아침부터 에러나는건 우리 예의가 아니지 ]]></summary></entry><entry><title type="html">multer</title><link href="http://localhost:4000/node.js/all/2024/01/12/multer.html" rel="alternate" type="text/html" title="multer" /><published>2024-01-12T12:00:00+09:00</published><updated>2024-01-12T12:00:00+09:00</updated><id>http://localhost:4000/node.js/all/2024/01/12/multer</id><content type="html" xml:base="http://localhost:4000/node.js/all/2024/01/12/multer.html"><![CDATA[<p>뮬터</p>

<h2 id="multer-모듈">Multer 모듈</h2>

<p>Multer는 Node.js 환경에서 파일 업로드를 처리하기 위한 미들웨어이다. Express와 함께 사용하면 파일 업로드를 쉽게 처리할 수 있으며, connect-multiparty와 비교하여 더 유연하고 안정적으로 파일 업로드를 처리할 수 있다.</p>

<p>Multer는 다양한 옵션을 제공하여 파일 업로드를 보다 세밀하게 제어할 수 있으며, 다양한 예외 상황에 대한 처리도 가능하다.</p>

<p>예를 들어, 파일 사이즈 제한, 파일 형식 제한, 파일 이름 중복 방지 등 다양한 옵션을 설정할 수 있다. 또한, Multer는 여러 파일을 동시에 업로드할 수 있으며, 업로드된 파일의 정보를 쉽게 가져올 수 있는 API도 제공한다.</p>

<p>Multer 모듈은 다음과 같이 설치할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install multer

</code></pre></div></div>

<p>Multer를 사용하기 위해서는 먼저 multer 모듈을 임포트해야 한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const multer = require('multer');

</code></pre></div></div>

<ol>
  <li>multer 모듈을 임포트한다.</li>
  <li>multer 객체를 생성한다. 이때, storage, limits, fileFilter 등의 옵션을 설정할 수 있다.</li>
  <li>multer 객체를 사용하여 파일 업로드를 처리한다. 이때, single, array, fields 등의 메소드를 사용하여 파일 업로드를 처리할 수 있다.</li>
</ol>

<h3 id="파일-업로드-처리">파일 업로드 처리</h3>

<p>multer는 http 요청의 본문에 포함된 파일을 서버로 업로드할 수 있도록 지원함</p>

<p>upload.single(fieldname) 또는 upload.array(fieldname[, maxCount])과 같은 메서드를 사용하여 단일 파일 또는 여러 파일을 처리할 수 있음</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const multer = require('multer');
const upload = multer({ dest: 'uploads/' });

app.post('/profile', upload.single('ramona'), (req, res, next) =&gt; {
  // req.file은 `ramona` 파일에 대한 정보
  // 키(`avatar`)는 multer 미들웨어가 사용되는 필드
})

</code></pre></div></div>

<ul>
  <li>multer는 HTTP 요청의 본문에 포함된 파일을 서버로 업로드할 수 있도록 지원한다</li>
  <li>upload.single(fieldname) 또는 upload.array(fieldname[, maxCount])과 같은 메서드를 사용하여 단일 파일 또는 여러 파일을 처리할 수 있다</li>
  <li>upload.single(fieldname)은 fieldname 필드의 단일 파일을 처리한다</li>
  <li>req.file 객체는 파일에 대한 정보를 담고 있다. fieldname은 upload.single() 메서드가 사용되는 필드 이름</li>
</ul>

<h3 id="파일-저장-경로-및-이름-지정">파일 저장 경로 및 이름 지정</h3>

<p>업로드된 파일의 저장 경로와 이름을 지정할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const multer = require('multer');
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, 'uploads/')
  },
  filename: function (req, file, cb) {
    cb(null, file.fieldname + '-' + Date.now())
  }
});
const upload = multer({ storage: storage });

</code></pre></div></div>

<ul>
  <li>storage 옵션을 설정해 파일 저장 위치, 파일 이름 규칙, 파일 확장자 등을 제어할 수 있다.</li>
  <li>multer.diskStorage() 메서드를 사용하여 파일 저장 경로와 파일 이름 규칙을 설정한다.</li>
  <li>cb 콜백 함수를 사용하여 저장 경로와 파일 이름을 반환한다.</li>
  <li>cb(null, ‘uploads/’)는 업로드된 파일이 uploads 폴더에 저장되도록 지정한다.</li>
  <li>cb(null, file.fieldname + ‘-‘ + Date.now())는 파일 이름을 fieldname-현재시간 형식으로 지정</li>
</ul>

<h3 id="파일-유효성-검사">파일 유효성 검사</h3>

<p>filefilter 옵션을 설정하여 허용되는 파일 확장자, 파일 크기 등을 제한할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const multer = require('multer');
const upload = multer({
  storage: storage,
  fileFilter: function (req, file, cb) {
    // 파일 필터링 로직
    if (!file.originalname.match(/\\\\\\\\.(jpg|jpeg|png|gif)$/)) {
      return cb(new Error('Only image files are allowed!'));
    }
    cb(null, true);
  }
});

</code></pre></div></div>

<ul>
  <li>fileFilter 옵션을 설정해 허용되는 파일 확장자, 파일 크기 등을 제한할 수 있다.</li>
  <li>fileFilter 콜백 함수는 업로드할 파일의 유효성을 검사한다.</li>
  <li>파일이 유효한 경우 cb(null, true)를 호출한다.</li>
  <li>유효하지 않은 경우 cb(new Error(‘Only image files are allowed!’))와 같이 에러를 반환한다</li>
</ul>

<h3 id="여러-필드-처리">여러 필드 처리</h3>

<p>단일 파일 뿐만 아니라 여러 필드(텍스트, 파일)등을 동시에 처리할 수 있다</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const multer = require('multer');
const upload = multer();

app.post('/profile', upload.fields([
  { name: 'avatar', maxCount: 1 },
  { name: 'gallery', maxCount: 8 }
]), (req, res, next) =&gt; {
  // req.files는 `avatar`와 `gallery` 파일에 대한 정보
  // 키(`avatar`와 `gallery`)는 multer 미들웨어가 사용되는 필드명
})
</code></pre></div></div>

<ul>
  <li>단일 파일 뿐만 아니라 여러 필드(텍스트, 파일)등을 동시에 처리할 수 있다.</li>
  <li>upload.fields(fields) 메서드를 사용하여 여러 필드를 처리한다.</li>
  <li>fields는 배열 형태로 필드 정보를 담고 있다</li>
  <li>필드 정보는 { name: 필드이름, maxCount: 파일 수 }의 형태로 지정한다.</li>
  <li>req.files 객체에는 { 필드이름: 파일정보 } 형태로 정보가 담겨 있다.</li>
</ul>]]></content><author><name>insidepixce</name></author><category term="all" /><category term="react" /><summary type="html"><![CDATA[뮬터]]></summary></entry><entry><title type="html">데이터 타입은 모르겠고 오류를 안 띄우려면</title><link href="http://localhost:4000/c/s/all/2024/01/12/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-copy.html" rel="alternate" type="text/html" title="데이터 타입은 모르겠고 오류를 안 띄우려면" /><published>2024-01-12T12:00:00+09:00</published><updated>2024-01-12T12:00:00+09:00</updated><id>http://localhost:4000/c/s/all/2024/01/12/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0%20copy</id><content type="html" xml:base="http://localhost:4000/c/s/all/2024/01/12/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-copy.html"><![CDATA[<p>​<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F7sekW%2Fbtsp3nRnHPg%2Fkls8pGQkvvgixWP3o19DsK%2Fimg.png" alt="썸네일" /></p>
<blockquote>
  <p>이 글은 <모던 자바스크립트="" 딥="" 다이브=""> 라는 책을 읽고 필자가 재구성하여 작성한 글입니다.</모던></p>
</blockquote>

<h1 id="데이터-타입의-필요성">데이터 타입의 필요성</h1>

<p>데이터 타입은 왜 필요한 것인가?</p>

<h2 id="️--데이터-타입에-의한-메모리-공간-확보와-참조를-위해">🙋‍♀️ : 데이터 타입에 의한 메모리 공간 확보와 참조를 위해</h2>

<p>값은 메모리에 저장하고 참조할 수 있어야 한다. 메모리에 값을 저장하려면 먼저 확보해야 할 메모리의 크기를 결정해야 한다.</p>

<p><img src="https://velog.velcdn.com/images/insidepixce/post/94364519-4048-4e4a-9eab-25152f4593e0/image.png" alt="" /></p>

<p>이렇게 숫자 타입 값이 할당된다.</p>

<blockquote>
  <p>자바스크립트는 숫자 타입의 값을 생성할 때 배정밀도 64비트 부동소수점 형식을 사용한다. 따라서 실제로 메모리에 저장되는 2진수 값은 위 그림과 다른다. 지금은 간단히 양의 정수로 저장된다고 생각하자</p>
</blockquote>

<p>→ 64비트 부동소수점 형식에 관해서는 이전에 다뤄보았다.</p>

<h3 id="--값을-생성할-때-명확한-기준이-없어-조금-헷갈리는걸">🤔 : 값을 생성할 때? 명확한 기준이 없어 조금 헷갈리는걸??</h3>

<p>→ 값을 생성할 때란 무엇인가???</p>

<p>프로그램이 실행되는 동안 변수에 할당되거나, 연산이 이루어지거나, 함수가 실행되면서 새로운 값을 만든다는 것을 의미</p>

<p>→ 변수를 선언하고 값을 할당하는 경우</p>

<p>→ 연산을 수행하는 경우</p>

<p>→ 함수를 실행하는 경우</p>

<p>즉 “자바스크립트에서 값을 생성한다” 는 것은 프로그램이 동작하면서 새로운 값을 만들고 변수에 저장하거나 결과로 반환하는 행위를 말한다.</p>

<h2 id="--자바스크립트에서-참조한다는-것은">🤷 : 자바스크립트에서 참조한다는 것은?</h2>

<ul>
  <li>변경이 가능한 값의 의미이다</li>
  <li>객체를 가리키는 변수를 다른 변tn 에 할당하면 원본의 참조 값이 복사되어 전달된다.</li>
</ul>

<p>자바스크립트에서 참조(Reference)는 변수가 객체나 배열과 같은 데이터 구조에 대한 메모리 주소를 가리키는 것을 의미한다. 다른 말로 하면, 참조는 실제 데이터가 위치한 메모리 영역에 직접 접근하는 것이 아니라, 데이터가 위치한 주소를 통해 해당 데이터에 접근하는 방법을 제공한다.</p>

<p>객체를 선언하여 생성한다</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const originalObject = {name : "insidepixce", age : 20};
</code></pre></div></div>

<p>변수 object가 originalObject를 가리킨다</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const referenceObject = originalObject;
</code></pre></div></div>

<p>referenceObject를 통해 Originalobject의 속성에 접근하고 수정한다</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>referenceObject.age = 21;
</code></pre></div></div>

<p>이때 originalObject와 referenceObject는 같은 객체를 가리키고 있다. 따라서 ‘referenceObject’를 통해 해당 객체의 속성을 수정하면 Original Object속의 속성도 같이 변경된다. 이는 객체의 데이터가 복사되지 않고 메모리 주소를 공유하기 떄문이다.</p>

<ul>
  <li>참조는 배열에서도 마찬가지로 동작한다</li>
</ul>

<p>즉, 식별자를 통해 메모리 공간의 주소를 찾아가는 것이다. 이때 값을 참조하려면 한번에 메모리를 몇 개를 읽어들여야 할지, 즉 메모리 셀의 개수(바이트 수)를 알아야 한다.</p>

<h3 id="--그럼-식별자-컴퓨터는-한-번에-읽어-들여야-할-메모리-셀의-크기를-어떻게-알-수-있는가">🙄 : 그럼 식별자 컴퓨터는 한 번에 읽어 들여야 할 메모리 셀의 크기를 어떻게 알 수 있는가?</h3>

<p><strong>🙆‍♀️ : 심벌 테이블이요!</strong></p>

<blockquote>
  <p>컴파일러 또는 인터프리터는 심벌 테이블이라고 부르는 자료 구조를 통해 식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리한다.</p>
</blockquote>

<p><strong>🤦‍♂️ : 그래서 심벌 테이블이 뭐냐고?</strong></p>

<p>컴파일러와 인터프리터 등의 프로그래밍 언어 처리 시스템에서 식별자를 관리하는 자료구조.</p>

<p>심벌 테이블은 각 식별자에 대해 이름과 해당 식별자가 사용되는 메모리 주소 또는 다른 정보를 매핑한다.</p>

<p>인터프리터는 식별자를 사용할 때 해당 식별자가 선언되었는지, 어떤 타입인지, 어느 범위에서 유효한지 등을 파악해야 한다. 이러한 정보는 실행 중인 프로그램에서 변수나 함수를 사용할 때 식별자가 가리키는 정확한 메모리 주소를 알고 있어야 하기 때문이다.</p>

<p><strong><em>심벌 테이블</em></strong>은 이러한 정보를 저장하고 유지 관리하는 역할을 한다. 컴파일러 또는 인터프리터는 소스코드를 분석하면서 식별자를 발견하면 해당 식별자와 관련된 정보를 심벌 테이블에 추가하거나 참조한다.</p>

<p>→ 일반적으로 해시 테이블 또는 기타 효율적인 데이터 구조를 사용하여 구현됨</p>

<p>→ 언어마다 다름</p>

<p>🌈 <strong><em>그래서 요약하자면!</em></strong></p>

<blockquote>
  <p>프로그래밍 언어 처리 시스템에서 식별자를 관리하고, 해당 식별자의 정보를 저장하고 유지 관리하는 자료구조. 이를 통해 변수와 함수 등의 식별자를 정확하게 해석하고 프로그램을 올바르게 처리할 수 있다.</p>
</blockquote>

<h1 id="-동적-타입-언어와-정적-타입-언어">🌷 동적 타입 언어와 정적 타입 언어</h1>

<p>자바스크립트의 모든 값은 데이터 값을 가진다.</p>

<blockquote>
  <p>🤔 : 그렇다면 변수는 데이터 타입을 가질까?</p>
</blockquote>

<p>정적 타입 언어는 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있음</p>

<p>→ 컴파일 시점에 <strong>타입체크</strong> 진행</p>

<p>→ 선언한 데이터 타입에 맞는 값을 할당했는지 보는 검사임</p>

<p>→ 이 검사 통과 못하면 실행 자체를 막음</p>

<p>타입의 일관성을 강제함으로서 더욱 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄인다</p>

<p>c, c++, 자바, 코틀린, 고, 하스켈, 러스트 , 스칼라 등등…</p>

<p>동적 타입 언어는 변수의 타입을 변경할 수 있으며, 변수에 할당된 값의 타입에 따라 실행 시점에 타입이 결정된다.</p>

<p>→ 변수의 타입을 설정하지 않고 값을 할당할 수 있음</p>

<p>→ 실행 도중에 변수의 타입이 자주 변경될 수 있음</p>

<p>→ 이로 인해 버그 발생 가능성이 높아짐</p>

<p>정적 타입 언어와 달리, 실행 시점에 타입이 결정되므로 타입 에러가 발생하기 쉽다. 따라서 개발자는 변수의 타입을 주의깊게 관리하고, 코드를 작성할 때 타입 에러를 방지할 수 있는 방법을 찾아야 한다.</p>

<blockquote>
  <p>typeof 연산자는 연산자 뒤에 위치한 피연산자의 데이터 타입을 문자열로 반환한다</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var foo;
console.log (typeof foo);

foo = 3;
console.log (typeof foo);
</code></pre></div></div>

<p>이런식으로 실행할 수 있다.</p>

<p>💡 변수의 데이터 타입을 반환하는 것이 아니라 변수에 할당된 값의 데이터 타입을 반환한다.</p>

<p>자바스크립트의 변수에는 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있다</p>

<p>→ 값을 할당하는 시점에 변수의 타입이 동적으로 결정뙤고 변수의 타입을 언제든지 자유롭게 변경할 수 있다</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>💯  자바스립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론) 되며,
재할당에 의해 변수의  타입은 언제든지 동적으로 변할 수 있다.
</code></pre></div></div>

<p>이러한 특징을 동적 타이핑이라고 하며, 자바스크립트를 정적 타입 언어와 구별짓기 위해 동적 타입 언어라고 한다. 대표적인 동적 타입 언어로는 자바스크립트, 파이썬, PHP, 루비, 리스프 , 펄 등이 있다.</p>

<p>이쯤 되어 아까 했던 질문으로 돌아가 보자</p>

<blockquote>
  <p>🤔 : 그렇다면 변수는 데이터 타입을 가질까?</p>
</blockquote>

<p>→ 기본적으로 변수는 타입을 갖지 않는다. 하지만 값은 타입을 갖는다.</p>

<p>따라서 현재 변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정된다고 표현하는 것이 더 적절하다.</p>

<p>변수는 값에 묶여 있는 값에 대한 별명이기 때문이다.</p>

<h1 id="-동적-타입-언어와-정적-타입-언어-1">🌷 동적 타입 언어와 정적 타입 언어</h1>

<p>동적 타입 언어는 변수에 어떤 값이라도 자유롭게 할당할 수 있다.</p>

<p>자바스크립트를 사용하다 보면 따로 변수 할당을 안 해줘도 원하는 타입으로 사용할 수 있기 때문에 이는 데이터 타입에 무감각해질 정도로 편리해진다.</p>

<p>그렇지만 편리함에 이면에는 위험도 있다.</p>

<blockquote>
  <p><strong>모든 소프트웨어 아키텍쳐에는 트레이드오프가 존재하며, 모든 애플리케이션에 적합한 은 탄환은 없듯이 동적 타입 언어 또한 구조적인 단점이 있다</strong></p>
</blockquote>

<p><em>Trade-off = 두 개의 정책이나 목표 중 하나를 달성하고자 하면 다른 목표의 달성이 늦어지거나 희생되는 모순적 관계를 의미함.</em></p>

<p><em>은 탄환: 아마 고질적인 문제를 단번에 해결할 수 있는 명쾌한 해결책…정도를 의미한듯</em></p>

<p>변수 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있다. 변수의 타입이 고정되어 있지 않고 동적으로 변한다.</p>

<p>→ 동적 타입 언어의 변수는 값의 변경에 의해 타입도 언제든지 변경될 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  💯 따라서 **동적 타입 언어의 변수는 값을 확인하기 전**에는 타입을 확신할 수 없다.
</code></pre></div></div>

<p>개발자의 의도와는 상관없어 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 한다.</p>

<p>잘못된 예측에 의해 오류를 뿜어내는 프로그램을 본다면… 🤦‍♀️</p>

<p>결국 동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다</p>

<h2 id="️-안정적인-프로그램을-만들고-싶어요">🙋‍♀️ 안정적인 프로그램을 만들고 싶어요!</h2>

<ul>
  <li>변수는 꼭 필요한 경우에 한해 제한적으로 사용한다</li>
  <li>변수의 유효 범위는 최대한 좁게 만들어 변수의 부작용을 억제해야 한다</li>
  <li>전역 변수는 최대한 사용하지 않도록 한다</li>
  <li>변수보다는 상수를 사용해 값의 변경을 억제한다</li>
  <li>변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다.</li>
</ul>

<p>사실 변수 오류는 그닥 많이 겪어보지 않았다. 내가 초보 개발자이며 아직 경험이 많이 없어서 그런지는 모른다. 하지만 책을 공부하다가 한번쯤은 정리해놓고 싶은 부분이라 작성해보았다.</p>]]></content><author><name>insidepixce</name></author><category term="all" /><category term="react" /><summary type="html"><![CDATA[​ 이 글은 라는 책을 읽고 필자가 재구성하여 작성한 글입니다.]]></summary></entry><entry><title type="html">동기비동기 한판정리</title><link href="http://localhost:4000/c/s/all/2024/01/12/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0.html" rel="alternate" type="text/html" title="동기비동기 한판정리" /><published>2024-01-12T12:00:00+09:00</published><updated>2024-01-12T12:00:00+09:00</updated><id>http://localhost:4000/c/s/all/2024/01/12/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/c/s/all/2024/01/12/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0.html"><![CDATA[<p>​<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FA6ni2%2Fbtsk1CjTRcs%2FQqlCB2OrK7jhEF8wpWKjTk%2Fimg.jpg" alt="썸네일" /></p>
<h2 id="동기비동기-정리">동기/비동기 정리</h2>

<p>동기/비동기는 자바스크립트에서 중요한 개념 중 하나이다. 동기는 코드가 순차적으로 실행된다는 것을 의미하며, 비동기는 코드가 순차적으로 실행되지 않는다는 것을 의미한다. 비동기 코드는 예측할 수 없는 순서로 실행되며, 실행이 완료되면 콜백 함수가 호출된다.</p>

<p>동기 코드의 예시는 다음과 같다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function add(x, y) {
  return x + y;
}

const result = add(1, 2);
console.log(result); // 3

</code></pre></div></div>

<p>위 코드에서 add 함수는 두 개의 숫자를 더한 값을 반환하는 일반적인 함수이다. 함수가 호출되면 결과가 즉시 반환되며, 결과는 result 변수에 할당된다. 이것은 동기 코드이다.</p>

<p>비동기 코드의 예시는 다음과 같다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setTimeout(() =&gt; {
  console.log('Hello, World!');
}, 1000);

</code></pre></div></div>

<p>위 코드에서 setTimeout 함수는 일정 시간이 지난 후에 실행될 콜백 함수를 등록하는 함수이다. 이 함수는 1초 후에 ‘Hello, World!’ 문자열을 콘솔에 출력한다. 이것은 비동기 코드이다. setTimeout 함수가 호출되면 결과가 즉시 반환되지 않으며, 1초 후에 콜백 함수가 호출된다.</p>

<p>따라서 자바스크립트에서는 비동기 함수를 항상 콜백 함수와 함께 사용해야 한다. 이를 통해 비동기 코드의 실행 순서를 보장하고, 비동기 함수가 완료된 후에 콜백 함수를 호출할 수 있다.</p>

<h2 id="예시">예시</h2>

<p>동기와 비동기를 이해하기 위해 일상 생활에서의 예시를 들어볼 수 있다.</p>

<p>예를 들어, 음식을 주문하는 것을 생각해보자. 동기 방식에서는 주문을 하면 음식이 나올 때까지 대기하며, 결과가 반환될 때까지 다른 일을 할 수 없다. 반면, 비동기 방식에서는 주문을 하고 나면 다른 스케줄을 세우거나, 다른 주문을 하거나, 롤이나 한 판 하는 등 다른 작업을 할 수 있다. 음식이 나오면 알림을 받아서 음식을 수령하고 먹으면 된다.</p>

<p>이와 같이 동기 방식은 결과가 반환될 때까지 대기해야 하며, 다른 작업을 수행할 수 없다. 반면, 비동기 방식은 결과가 반환되기를 기다리지 않고 다른 작업을 수행할 수 있다.</p>

<h1 id="예시-1">예시</h1>
<ul>
  <li>
    <h3 id="-시나리오-1-">[ 시나리오 1 ]</h3>
  </li>
  <li>개발팀장이 3명의 사원에게 동시다발적으로 각각의 업무를 지시한다. ( = 비동기 )</li>
  <li>놀랍게도 개발팀장은 3명의 사원에게 시킨 일을 확인도 안하고 본인 할 일도 한다 ( = 비동기 )</li>
  <li>
    <p>사원마다 맡은 일을 알아서 끝내고 개발팀장에게 보고한다. ( = 논블로킹 )</p>
  </li>
  <li>
    <h3 id="-시나리오-2-">[ 시나리오 2 ]</h3>
  </li>
  <li>개발팀장이 사원1 에게 업무를 지시한다.</li>
  <li>그리고 사원1 업무가 끝날때까지 언제 끝나냐고 눈초리를 준다. ( = 동기 )</li>
  <li>사원1 의 업무처리가 너무 느려서 다른 사원에게 일을 주려고한다. ( = 비동기 )</li>
  <li>그런데 사원1 은 도와달라며 개발팀장의 옷자락을 붙잡는다. ( = 블로킹 )</li>
  <li>그걸 지켜보는 사원2 와 사원3 은 무슨 일을 주던 열심히 할 생각은 있지만 일이 없다. ( = 동기 )</li>
</ul>

<h2 id="요약">요약</h2>

<p>동기/비동기 프로그래밍은 모든 프로그래밍 언어에서 중요한 개념 중 하나이다. 동기 프로그래밍은 코드가 순차적으로 실행되며, 결과가 즉시 반환된다는 것을 의미한다. 비동기 프로그래밍은 코드가 순차적으로 실행되지 않으며, 결과가 바로 반환되지 않는다는 것을 의미한다.</p>

<p>비동기 함수는 대개 비동기 콜백 함수와 함께 사용되며, 콜백 함수는 비동기 함수가 완료된 후에 호출된다. 이를 통해 프로그램이 예측 가능한 방식으로 실행되는 것을 보장할 수 있다. 예를 들어, 파일을 읽는 비동기 함수는 파일이 성공적으로 읽혔을 때 콜백 함수를 호출하여 결과를 반환한다.</p>

<p>동기 함수와 비동기 함수는 각각의 장단점이 있으며, 상황에 따라 적절한 방식을 선택해야 한다. 일반적으로, 네트워크 요청과 같은 오래 걸리는 작업을 수행할 때는 비동기 함수를 사용하는 것이 좋다. 이를 통해 사용자 인터페이스가 응답성을 유지하면서 백그라운드 작업이 수행될 수 있다.</p>

<h1 id="이해가-안-갈-까봐-예시를-더-만들어봤습니다">이해가 안 갈 까봐 예시를 더 만들어봤습니다</h1>

<h2 id="예시-1-커피-주문하기">예시 1: 커피 주문하기</h2>

<h3 id="동기적인-상황">동기적인 상황:</h3>
<p>고객이 커피 주문을 하면, 커피를 만드는 동안 다른 주문은 받지 않는다
주문이 완료되고 커피가 나오면, 그 다음 주문을 받는다</p>

<h3 id="비동기적인-상황">비동기적인 상황:</h3>
<p>고객이 커피 주문을 하면, 주문은 바로 받아들이고 고객에게 예상 소요 시간을 알려준다 
커피가 만들어지는 동안에도 다른 주문을 받아줄 수 있다
각 주문이 완료되면, 그때마다 손님에게 알림을 주고 커피를 준다.</p>

<p>동기적인 프로그래밍은 한 작업이 끝나야 다음 작업이 시작되는 반면, 비동기적인 프로그래밍은 여러 작업이 동시에 진행될 수 있고, 완료된 순서대로 결과를 얻을 수 있다는 것을 이해해야만 한다. 이러한 특성은 주로 네트워크 요청, 파일 다운로드, 사용자 인터랙션 등의 상황에서 뚜렷하게 나타난다.</p>]]></content><author><name>insidepixce</name></author><category term="all" /><category term="react" /><summary type="html"><![CDATA[​ 동기/비동기 정리]]></summary></entry><entry><title type="html">20240110TIL</title><link href="http://localhost:4000/til/all/2024/01/12/TIL.html" rel="alternate" type="text/html" title="20240110TIL" /><published>2024-01-12T12:00:00+09:00</published><updated>2024-01-12T12:00:00+09:00</updated><id>http://localhost:4000/til/all/2024/01/12/TIL</id><content type="html" xml:base="http://localhost:4000/til/all/2024/01/12/TIL.html"><![CDATA[<p>독감은 독해서 독감이구나</p>

<p>티아이엘.</p>
<h1 id="오늘의-피드백">오늘의 피드백</h1>

<h3 id="컴포넌트의-재사용성">컴포넌트의 재사용성</h3>

<p>컴포넌트의 재사용성 진짜 중요하다. 최적화와 너무 깊게 연관되어 있기 때문이다. 이번 프로젝트 진행 중 상품 목록 페이지를 개발하면서, 각 상품 카드를 표시하는 부분을 여러 곳에서 사용하여야 했다. 이러한 상황에서 재사용 가능한 컴포넌트를 어떻게 설계하고 최적화하는지에 대한 고민을 많이 하게 되었다.</p>

<p>재사용성을 높이기 위해 컴포넌트들을 작은 단위로 분류하고 props를 통해 데이터를 동적으로 전달하는 방식으로 개발했다. 또한, React.memo 나 PureComponent 와 같은 최적화 기술을 활용하여 불필요한 리렌더링을 방지하고 성능을 향상시키는 방법을 생각해봐야 할 것 같다</p>

<h3 id="상태-관리의-복잡성과-미들웨어">상태 관리의 복잡성과 미들웨어</h3>

<p>위에서 언급한 Redux를 사용하여 상태 관리를 하는데 복잡하더라. 특히 비동기 작업과 관련된 부분이 어려웠다. . Redux Thunk, Redux Saga, Redux Observable 등 미들웨어가 너무 많아서 어떤걸 선택해야 할지 혼란스러웠다. 비동기 작업을 효과적으로 처리하고 상태 관리의 복잡성을 줄이기 위해 Redux Thunk 를 활용하여 API 호출 및 데이터 처리를 구현해보았다. 고르기 진짜 힘들었따</p>

<h3 id="상태-최적화와-선택적-리렌더링">상태 최적화와 선택적 리렌더링</h3>

<p>→ 대규모 앱에서는 성능 최적화가 중요한 이슈이다. Reselect와 같은 라이브러리를 활용해보았지만 사실 나는 별다른걸 못 느꼈다.</p>

<h1 id="오늘의-이슈">오늘의 이슈</h1>

<ol>
  <li><strong>상품 목록을 불러오는 동안 네트워크 연결이 불안정한 상황에서 API 호출이 실패하는 문제가 발생했다.</strong></li>
</ol>

<p>→ Redux의 ‘fetchUser.rejected’ 케이스가 트리거되어 오류 메세지를 Redux 상태에 저장했다.’</p>

<p>앱이 서버로 api요청을 보내는 도중에 네트워크 연결이 불안정한 상황이 발생했다. API 호출이 실패하고 대신 오류 응답을 받게 되었다.</p>

<p>→ Redux의 ‘fetchUser.rejected’케이스 트리거: Redux를 사용하여 API 호출을 관리하고 있을 때, Redux Toolkit과 Redux Thunk 등을 활용하여 비동기 액션을 처리하는데, 호출이 실패하면 자동으로 ‘Rejected’케이스가 트리거된다. 이 경우, Redux에서 사용자가 정의한 ‘fetchUser’액션에 대한 ‘rejected’케이스가 실행된다</p>

<p>→’fetchUser.rejected’케이스에서는 API 호출 실패와 관련된 오류 메시지를 포함한 액션 객체가 생성된다. 이 오류 메시지는 Redux 상태에 저장되고, 일반적으로 Redux 상태에는 error 또는 errorMessage와 같은 필드가 있어 오류 메시지를 저장할 수 있다</p>

<p>👰🏻 사실 불안정한 네트워크 연결에 대한 해결책은 아니다. 길이 없는데 어떻게 가겠는가. 그냥, 오류 메시지를 어떻게 담을 것인지 확인했다.</p>

<ol>
  <li><strong>사용자 인증 토큰이 만료되어 API 요청이 실패했다</strong></li>
</ol>

<p>→ 토큰 만료를 감지하고 리프레시 토큰을 사용하여 새로운 액세스 토큰을 얻어 API 요청을 재시도한다</p>

<p>→ 인증 토큰 만료에 대한 오류 핸들링을 통해 사용자에게 다시 로그인을 유도한다</p>

<p>이것도 Redux의 도움을 얻어보았다. fetchUser액션에서 토큰 만료 오류가 발생했을 때 리프레시 토큰을 사용하여 새로운 액세스 토큰을 얻는 과정이다</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const fetchUser = createAsyncThunk('user/fetchUser', async (_, { dispatch, rejectWithValue }) =&gt; {
  try {
    const response = await fetch('/api/user', {
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
    });
    const data = await response.json();
    return data;
  } catch (error) {
    // 토큰 만료 오류인 경우 리프레시 토큰을 사용하여 재인증 시도
    if (error.message === 'TokenExpiredError') {
      try {
        const newAccessToken = await dispatch(refreshToken());
        // 새로 받은 액세스 토큰을 사용하여 다시 API 요청을 시도
        const response = await fetch('/api/user', {
          headers: {
            Authorization: `Bearer ${newAccessToken}`,
          },
        });
        const data = await response.json();
        return data;
      } catch (refreshError) {
        // 리프레시 토큰으로도 재인증에 실패한 경우
        return rejectWithValue('로그인이 필요합니다.'); // 오류 메시지 반환
      }
    }
    return rejectWithValue(error.message);
  }
});
</code></pre></div></div>

<ol>
  <li>서<strong>버에서 받은 데이터의 유효성을 검사하는 과정에서 실패했다</strong></li>
</ol>

<p>외부 데이터 소스에서 데이터를 가져와서 사용하는 중이였는데, 데이터 형식이 일치하지 않아 오류가 발생했다.</p>

<p>데이터 유효성 검사 오류 = 애플리케이션 서버로부터 받은 데이터가 예상과 다른 형식이거나 유효하지 않을 때 발생할 수 있는 어려움이다. → 데이터 형식 명확히 정의하기 : 서버와 클라이언트간에 통신할때 데이터의 형식을 명확히 정의해야 한다.</p>

<p>→ Joi /Yup 과 같은 유효성 검사 라이브러리를 사용한다 : 클라이언트 측에서는 Joi 나 Yup 같은 유효성 검사 라이브러리를 사용하여 데이터의 유효성을 간편하게 검사할 수 있다. 이러한 라이브러리를 활용하면 데이터 스키마를 정의하고 데이터를 검증하는 과정을 간소화할 수 있다</p>

<h1 id="화면-전환시에-화면전환-애니를-사용자-정의하고-싶다면">화면 전환시에 화면전환 애니를 사용자 정의하고 싶다면?</h1>

<p>작업 중에 조금 밋밋했던 부분이 있었다. 리엑트 네이티브에서 화면 전환 애니메이션을 사용자 정의하는 것이 가능하고, ‘react-navigation’이라는 라이브러리를 활용하여 구현할 수 있다’</p>

<p>화면 전환 애니메이션을 구현하려면 ‘createStackNavigator’함수를 사용하여 네비게이션 스택을 만들고, screenOptions 속성을 활용하여 사용자 정의 애니메이션을 설정해줄 수 있다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">NavigationContainer</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@react-navigation/native</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">createStackNavigator</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@react-navigation/stack</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">Stack</span> <span class="o">=</span> <span class="nx">createStackNavigator</span><span class="p">();</span>

<span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">NavigationContainer</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nc">Stack</span><span class="p">.</span><span class="nc">Navigator</span>
        <span class="na">initialRouteName</span><span class="p">=</span><span class="s">"Home"</span>
        <span class="na">screenOptions</span><span class="p">=</span><span class="si">{</span><span class="p">{</span>
          <span class="na">cardStyleInterpolator</span><span class="p">:</span> <span class="p">({</span> <span class="nx">current</span><span class="p">,</span> <span class="nx">layouts</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{</span>
              <span class="na">cardStyle</span><span class="p">:</span> <span class="p">{</span>
                <span class="na">transform</span><span class="p">:</span> <span class="p">[</span>
                  <span class="p">{</span>
                    <span class="na">translateX</span><span class="p">:</span> <span class="nx">current</span><span class="p">.</span><span class="nx">progress</span><span class="p">.</span><span class="nx">interpolate</span><span class="p">({</span>
                      <span class="na">inputRange</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                      <span class="na">outputRange</span><span class="p">:</span> <span class="p">[</span><span class="nx">layouts</span><span class="p">.</span><span class="nx">screen</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="p">}),</span>
                  <span class="p">},</span>
                <span class="p">],</span>
              <span class="p">},</span>
            <span class="p">};</span>
          <span class="p">},</span>
        <span class="p">}</span><span class="si">}</span>
      <span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nc">Stack</span><span class="p">.</span><span class="nc">Screen</span> <span class="na">name</span><span class="p">=</span><span class="s">"Home"</span> <span class="na">component</span><span class="p">=</span><span class="si">{</span><span class="nx">HomeScreen</span><span class="si">}</span> <span class="p">/&gt;</span>
        <span class="p">&lt;</span><span class="nc">Stack</span><span class="p">.</span><span class="nc">Screen</span> <span class="na">name</span><span class="p">=</span><span class="s">"Details"</span> <span class="na">component</span><span class="p">=</span><span class="si">{</span><span class="nx">DetailsScreen</span><span class="si">}</span> <span class="p">/&gt;</span>
      <span class="p">&lt;/</span><span class="nc">Stack</span><span class="p">.</span><span class="nc">Navigator</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nc">NavigationContainer</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>
<p>화면 전환 시 애니메이션이 오른쪽으로 슬라이드되는 효과를 정의해보았다. ‘cardStyleInterpolator’ 함수 내에서 애니메이션을 정의했다. ‘inputRange’와 ‘outputrange’를 조절하여 다양한 애니메이션 효과를 적용했다</p>

<p>저건 연습 코드였고, 실제 프로젝트에서는 좀 더 복잡한 애니메이션을 구현해줬는데, react-navigation 라이브러리의 다양한 옵션들을 정리해보려 한다.</p>

<h3 id="내가-주로-쓸-것-같은-옵션들-모음-react-navigation-">내가 주로 쓸 것 같은 옵션들 모음 (react-navigation )</h3>

<ul>
  <li><strong>createStackNavigator - ‘screenOptions’</strong></li>
</ul>

<p>스택 네비게이터를 생성할 때 화면 전환에 관련된 옵션 설정가능</p>

<p>‘cardStyleInterpolator : 화면 전환 애니메이션을 사용자 정의할 수 있게 하는 함수를 지정한다. 화면 슬라이드. 페이드, 회전 등 다양한 애니메이션 효과 정의 가능! !</p>

<p>‘headerStyle’: 화면 헤더의 스타일을 설정한다. 배경색, 그림자, 높이 등을 조절할 수 있다</p>

<p>‘headerTintColor’: 헤더 아이콘 및 텍스트의 샞상을 설정한다</p>

<p>‘headerTitleStyle” : 헤더 제목의 스타일 설정</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>‘createBottomTabNavigator’ 및 ‘createMaterialBottomTabNavigator’**
</code></pre></div></div>
<p>탭 네비게이터 생성 시 다양한 옵션을 사용하여 탭의 모양과 동작을 조절할 수 있다. 예를 들어 , ‘ tabBarIcon’을 사용하여 각 탭에 아이콘을 지정하거나, ‘tabBarOptions’를 사용하여 탭바의 스타일을 설정할 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-   **‘createDrawerNavigator’:**
</code></pre></div></div>
<p>드로어 네비게이터를 생성할 때 ‘drawerContent’나 ‘drawerStyle’등을 사용하여 드로어의 내용과 스타일을 조절할 수 있다</p>

<h1 id="데이터베이스-충돌">데이터베이스 충돌</h1>

<p>데이터베이스에 사용자 정보를 저장했다. 근데, 동시에 두 사용자가 동일한 사용자 정보를 수정하려고 시도하면 어떻게 될까 궁금해서 해봤다.</p>

<ul>
  <li>사용자 A는 웹 앱에서 자신의 사용자 정보를 수정하려고 한다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const updateUserA = async () =&gt; {
	const user = await getUserFromDB(1);\\
	user.age = 31;
	await updateUserInDB(user);
};
</code></pre></div></div>

<ul>
  <li>동일한 시간에 사용자 B도 자신의 정보를 수정하려고 한다</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const updateUserB = async () =&gt; {
	const user = await getUIserFromDB(1);
	user.age = 32;
	await updateUserInDB(user);
</code></pre></div></div>

<p>→ 충돌 발생</p>

<ul>
  <li>사용자 a와 사용자 b는 동시에 데이터베이스에서 동일한 사용자 정보를 가져와 수정하고 저장하려고 한다. 데이터베이스에는 사용자 a와 b가 동시에 업데이트를 시도하므로 충돌이 발생한다</li>
  <li>충돌이 발생한 후 , 데이터베이스에서 최정적으로 저장된 사용자 정보를 마지막으로 업데이트해서 반영한다</li>
</ul>

<h2 id="충돌이-해결되는-과정">충돌이 해결되는 과정</h2>

<ol>
  <li>데이터베이스 업데이트</li>
</ol>

<ul>
  <li>사용자 A와 사용자 B가 동시에 데이터베이스의 사용자 정보를 가져오고 수정합니다.</li>
  <li>각각의 업데이트는 데이터베이스 트랜젝션 내에서 처리된다</li>
</ul>

<ol>
  <li>데이터베이스 충돌 감지</li>
</ol>

<ul>
  <li>데이터베이스는 사용자 A와 사용자 B의 업데이트가 동시에 실행되어 충돌이 발생했음을 감지한다</li>
</ul>

<ol>
  <li>충돌 해결</li>
</ol>

<ul>
  <li>충돌 해결에는 두가지 방법이 있다.
    <ul>
      <li>비관적 잠금 (Pessimistic Locking) : 사용자 A가 데이터를 가져올 때 데이터베이스에서 해당 데이터를 잠그고, 사용자 B는 데이터를 가져오는 동안 기다려야 한다. 이후 사용자 A와 B중 먼저 업데이트를 시도한 사용자의 변경 내용이 반영된다</li>
      <li>낙관적 잠금(Optimistic Locking) : 사용자 A와 B가 데이터를 가져온 후 업데이트를 시도한다. 데이터베이스에서는 A와 B애가 가져온 데이터의 버전을 비교한다. 만약 버전이 동일하다면 업데이트를 허용하고 , 버전이 다르다면 충돌이 감지되었다고 알린다. 이후 A와 B에게 충돌을 해결하라고 선택권을 주거나, 나중에 다시 시도하도록 유도한다</li>
    </ul>
  </li>
</ul>

<ol>
  <li>최종 업데이트</li>
</ol>

<ul>
  <li>충돌이 해결되고 데이터베이스에서 사용자 A와 B의 업데이트를 모두 반영한 후 , 최종 사용자 정보가 데이터베이스에 저장된다</li>
  <li>이때, 마지막으로 업데이트한 사용자의 변경 내용이 반영되므로, 최종 나이가 32인 경우에는 사용자 B의 업데이트가 마지막으로 반영된 경우이다.</li>
</ul>

<ol>
  <li>응답 및 결과</li>
</ol>

<ul>
  <li>데이터베이스가 최종 업데이트를 수행한 후 , 사용자 A와 B에게 각각의 요청에 대한 응답을 반환합니다</li>
  <li>응답은 수정 후의 최종 결과를 나타내며, 데이터베이스에서 저장된 최신 상태를 반영한다</li>
</ul>

<p>이렇게 충돌이 발생하고 해결되면 최종적으로 데이터베이스에 반영된 결과를 사용자 A와 B에게 반환하여 제공된다. 충돌이 발생할 경우 충돌 해결 전까지 어느 한 사용자의 업데이트가 최종 반영되지 않은 것이다</p>

<h2 id="오늘-하루-리뷰">오늘 하루 리뷰 </h2>

<p>오늘 몸이 너무 안따라준다. 헤롱헤롱한다. 너무 아프다. 진짜 두통이 너무 심하다. 글자를 읽을 때마다 울렁거린다. 약간 속도 메스껍고 토할 것 같다. 잠이 너무 온다. 죽을 것 같다 진짜. 속도 안좋다. 잠도 많이 온다. 어제부터 죽을 것 같아서 몬스터 흰색 캔을 2개를 땄다. 어쩌겠니… 돈벌어야 하는데…</p>

<p>몸이 너무 아프다. 잠이 너무 많아진다. 이러다가 진짜 죽는건 아닐지 하고 아픈데 열은 또 안 난다. 춥고 덥다. 근데 또 갑자기 미친듯이 먹고싶을때가 있다. 또 밥먹기 싫을때는 미친듯이 먹기 싫다.</p>

<p>이게 무슨 일이람… 내과 가서 물어봐야 하나,,,</p>

<p>글자 보면 울렁거려서 못참겠다니깐.</p>

<p>그래도 해야지 어떡해…그래도 해야지 어떡해.</p>

<p>독감이 괜히 독감이 아닌가봐…독해서 독감이야</p>]]></content><author><name>insidepixce</name></author><category term="all" /><category term="react" /><summary type="html"><![CDATA[독감은 독해서 독감이구나]]></summary></entry></feed>