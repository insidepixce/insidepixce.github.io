<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.4">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-01-12T14:59:59+09:00</updated><id>/feed.xml</id><title type="html">Insidepixce</title><subtitle>살아가는 방법을 다룹니다</subtitle><author><name>insidepixce</name></author><entry><title type="html">20240110TIL</title><link href="/til/all/2024/01/12/TIL.html" rel="alternate" type="text/html" title="20240110TIL" /><published>2024-01-12T12:00:00+09:00</published><updated>2024-01-12T12:00:00+09:00</updated><id>/til/all/2024/01/12/TIL</id><content type="html" xml:base="/til/all/2024/01/12/TIL.html"><![CDATA[<p>독감은 독해서 독감이구나</p>

<p>티아이엘.</p>
<h1 id="오늘의-피드백">오늘의 피드백</h1>

<h3 id="컴포넌트의-재사용성">컴포넌트의 재사용성</h3>

<p>컴포넌트의 재사용성 진짜 중요하다. 최적화와 너무 깊게 연관되어 있기 때문이다. 이번 프로젝트 진행 중 상품 목록 페이지를 개발하면서, 각 상품 카드를 표시하는 부분을 여러 곳에서 사용하여야 했다. 이러한 상황에서 재사용 가능한 컴포넌트를 어떻게 설계하고 최적화하는지에 대한 고민을 많이 하게 되었다.</p>

<p>재사용성을 높이기 위해 컴포넌트들을 작은 단위로 분류하고 props를 통해 데이터를 동적으로 전달하는 방식으로 개발했다. 또한, React.memo 나 PureComponent 와 같은 최적화 기술을 활용하여 불필요한 리렌더링을 방지하고 성능을 향상시키는 방법을 생각해봐야 할 것 같다</p>

<h3 id="상태-관리의-복잡성과-미들웨어">상태 관리의 복잡성과 미들웨어</h3>

<p>위에서 언급한 Redux를 사용하여 상태 관리를 하는데 복잡하더라. 특히 비동기 작업과 관련된 부분이 어려웠다. . Redux Thunk, Redux Saga, Redux Observable 등 미들웨어가 너무 많아서 어떤걸 선택해야 할지 혼란스러웠다. 비동기 작업을 효과적으로 처리하고 상태 관리의 복잡성을 줄이기 위해 Redux Thunk 를 활용하여 API 호출 및 데이터 처리를 구현해보았다. 고르기 진짜 힘들었따</p>

<h3 id="상태-최적화와-선택적-리렌더링">상태 최적화와 선택적 리렌더링</h3>

<p>→ 대규모 앱에서는 성능 최적화가 중요한 이슈이다. Reselect와 같은 라이브러리를 활용해보았지만 사실 나는 별다른걸 못 느꼈다.</p>

<h1 id="오늘의-이슈">오늘의 이슈</h1>

<ol>
  <li><strong>상품 목록을 불러오는 동안 네트워크 연결이 불안정한 상황에서 API 호출이 실패하는 문제가 발생했다.</strong></li>
</ol>

<p>→ Redux의 ‘fetchUser.rejected’ 케이스가 트리거되어 오류 메세지를 Redux 상태에 저장했다.’</p>

<p>앱이 서버로 api요청을 보내는 도중에 네트워크 연결이 불안정한 상황이 발생했다. API 호출이 실패하고 대신 오류 응답을 받게 되었다.</p>

<p>→ Redux의 ‘fetchUser.rejected’케이스 트리거: Redux를 사용하여 API 호출을 관리하고 있을 때, Redux Toolkit과 Redux Thunk 등을 활용하여 비동기 액션을 처리하는데, 호출이 실패하면 자동으로 ‘Rejected’케이스가 트리거된다. 이 경우, Redux에서 사용자가 정의한 ‘fetchUser’액션에 대한 ‘rejected’케이스가 실행된다</p>

<p>→’fetchUser.rejected’케이스에서는 API 호출 실패와 관련된 오류 메시지를 포함한 액션 객체가 생성된다. 이 오류 메시지는 Redux 상태에 저장되고, 일반적으로 Redux 상태에는 error 또는 errorMessage와 같은 필드가 있어 오류 메시지를 저장할 수 있다</p>

<p>👰🏻 사실 불안정한 네트워크 연결에 대한 해결책은 아니다. 길이 없는데 어떻게 가겠는가. 그냥, 오류 메시지를 어떻게 담을 것인지 확인했다.</p>

<ol>
  <li><strong>사용자 인증 토큰이 만료되어 API 요청이 실패했다</strong></li>
</ol>

<p>→ 토큰 만료를 감지하고 리프레시 토큰을 사용하여 새로운 액세스 토큰을 얻어 API 요청을 재시도한다</p>

<p>→ 인증 토큰 만료에 대한 오류 핸들링을 통해 사용자에게 다시 로그인을 유도한다</p>

<p>이것도 Redux의 도움을 얻어보았다. fetchUser액션에서 토큰 만료 오류가 발생했을 때 리프레시 토큰을 사용하여 새로운 액세스 토큰을 얻는 과정이다</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const fetchUser = createAsyncThunk('user/fetchUser', async (_, { dispatch, rejectWithValue }) =&gt; {
  try {
    const response = await fetch('/api/user', {
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
    });
    const data = await response.json();
    return data;
  } catch (error) {
    // 토큰 만료 오류인 경우 리프레시 토큰을 사용하여 재인증 시도
    if (error.message === 'TokenExpiredError') {
      try {
        const newAccessToken = await dispatch(refreshToken());
        // 새로 받은 액세스 토큰을 사용하여 다시 API 요청을 시도
        const response = await fetch('/api/user', {
          headers: {
            Authorization: `Bearer ${newAccessToken}`,
          },
        });
        const data = await response.json();
        return data;
      } catch (refreshError) {
        // 리프레시 토큰으로도 재인증에 실패한 경우
        return rejectWithValue('로그인이 필요합니다.'); // 오류 메시지 반환
      }
    }
    return rejectWithValue(error.message);
  }
});
</code></pre></div></div>

<ol>
  <li>서<strong>버에서 받은 데이터의 유효성을 검사하는 과정에서 실패했다</strong></li>
</ol>

<p>외부 데이터 소스에서 데이터를 가져와서 사용하는 중이였는데, 데이터 형식이 일치하지 않아 오류가 발생했다.</p>

<p>데이터 유효성 검사 오류 = 애플리케이션 서버로부터 받은 데이터가 예상과 다른 형식이거나 유효하지 않을 때 발생할 수 있는 어려움이다. → 데이터 형식 명확히 정의하기 : 서버와 클라이언트간에 통신할때 데이터의 형식을 명확히 정의해야 한다.</p>

<p>→ Joi /Yup 과 같은 유효성 검사 라이브러리를 사용한다 : 클라이언트 측에서는 Joi 나 Yup 같은 유효성 검사 라이브러리를 사용하여 데이터의 유효성을 간편하게 검사할 수 있다. 이러한 라이브러리를 활용하면 데이터 스키마를 정의하고 데이터를 검증하는 과정을 간소화할 수 있다</p>

<h1 id="화면-전환시에-화면전환-애니를-사용자-정의하고-싶다면">화면 전환시에 화면전환 애니를 사용자 정의하고 싶다면?</h1>

<p>작업 중에 조금 밋밋했던 부분이 있었다. 리엑트 네이티브에서 화면 전환 애니메이션을 사용자 정의하는 것이 가능하고, ‘react-navigation’이라는 라이브러리를 활용하여 구현할 수 있다’</p>

<p>화면 전환 애니메이션을 구현하려면 ‘createStackNavigator’함수를 사용하여 네비게이션 스택을 만들고, screenOptions 속성을 활용하여 사용자 정의 애니메이션을 설정해줄 수 있다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">NavigationContainer</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@react-navigation/native</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">createStackNavigator</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@react-navigation/stack</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">Stack</span> <span class="o">=</span> <span class="nx">createStackNavigator</span><span class="p">();</span>

<span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">NavigationContainer</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nc">Stack</span><span class="p">.</span><span class="nc">Navigator</span>
        <span class="na">initialRouteName</span><span class="p">=</span><span class="s">"Home"</span>
        <span class="na">screenOptions</span><span class="p">=</span><span class="si">{</span><span class="p">{</span>
          <span class="na">cardStyleInterpolator</span><span class="p">:</span> <span class="p">({</span> <span class="nx">current</span><span class="p">,</span> <span class="nx">layouts</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{</span>
              <span class="na">cardStyle</span><span class="p">:</span> <span class="p">{</span>
                <span class="na">transform</span><span class="p">:</span> <span class="p">[</span>
                  <span class="p">{</span>
                    <span class="na">translateX</span><span class="p">:</span> <span class="nx">current</span><span class="p">.</span><span class="nx">progress</span><span class="p">.</span><span class="nx">interpolate</span><span class="p">({</span>
                      <span class="na">inputRange</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                      <span class="na">outputRange</span><span class="p">:</span> <span class="p">[</span><span class="nx">layouts</span><span class="p">.</span><span class="nx">screen</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="p">}),</span>
                  <span class="p">},</span>
                <span class="p">],</span>
              <span class="p">},</span>
            <span class="p">};</span>
          <span class="p">},</span>
        <span class="p">}</span><span class="si">}</span>
      <span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nc">Stack</span><span class="p">.</span><span class="nc">Screen</span> <span class="na">name</span><span class="p">=</span><span class="s">"Home"</span> <span class="na">component</span><span class="p">=</span><span class="si">{</span><span class="nx">HomeScreen</span><span class="si">}</span> <span class="p">/&gt;</span>
        <span class="p">&lt;</span><span class="nc">Stack</span><span class="p">.</span><span class="nc">Screen</span> <span class="na">name</span><span class="p">=</span><span class="s">"Details"</span> <span class="na">component</span><span class="p">=</span><span class="si">{</span><span class="nx">DetailsScreen</span><span class="si">}</span> <span class="p">/&gt;</span>
      <span class="p">&lt;/</span><span class="nc">Stack</span><span class="p">.</span><span class="nc">Navigator</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nc">NavigationContainer</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>
<p>화면 전환 시 애니메이션이 오른쪽으로 슬라이드되는 효과를 정의해보았다. ‘cardStyleInterpolator’ 함수 내에서 애니메이션을 정의했다. ‘inputRange’와 ‘outputrange’를 조절하여 다양한 애니메이션 효과를 적용했다</p>

<p>저건 연습 코드였고, 실제 프로젝트에서는 좀 더 복잡한 애니메이션을 구현해줬는데, react-navigation 라이브러리의 다양한 옵션들을 정리해보려 한다.</p>

<h3 id="내가-주로-쓸-것-같은-옵션들-모음-react-navigation-">내가 주로 쓸 것 같은 옵션들 모음 (react-navigation )</h3>

<ul>
  <li><strong>createStackNavigator - ‘screenOptions’</strong></li>
</ul>

<p>스택 네비게이터를 생성할 때 화면 전환에 관련된 옵션 설정가능</p>

<p>‘cardStyleInterpolator : 화면 전환 애니메이션을 사용자 정의할 수 있게 하는 함수를 지정한다. 화면 슬라이드. 페이드, 회전 등 다양한 애니메이션 효과 정의 가능! !</p>

<p>‘headerStyle’: 화면 헤더의 스타일을 설정한다. 배경색, 그림자, 높이 등을 조절할 수 있다</p>

<p>‘headerTintColor’: 헤더 아이콘 및 텍스트의 샞상을 설정한다</p>

<p>‘headerTitleStyle” : 헤더 제목의 스타일 설정</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>‘createBottomTabNavigator’ 및 ‘createMaterialBottomTabNavigator’**
</code></pre></div></div>
<p>탭 네비게이터 생성 시 다양한 옵션을 사용하여 탭의 모양과 동작을 조절할 수 있다. 예를 들어 , ‘ tabBarIcon’을 사용하여 각 탭에 아이콘을 지정하거나, ‘tabBarOptions’를 사용하여 탭바의 스타일을 설정할 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-   **‘createDrawerNavigator’:**
</code></pre></div></div>
<p>드로어 네비게이터를 생성할 때 ‘drawerContent’나 ‘drawerStyle’등을 사용하여 드로어의 내용과 스타일을 조절할 수 있다</p>

<h1 id="데이터베이스-충돌">데이터베이스 충돌</h1>

<p>데이터베이스에 사용자 정보를 저장했다. 근데, 동시에 두 사용자가 동일한 사용자 정보를 수정하려고 시도하면 어떻게 될까 궁금해서 해봤다.</p>

<ul>
  <li>사용자 A는 웹 앱에서 자신의 사용자 정보를 수정하려고 한다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const updateUserA = async () =&gt; {
	const user = await getUserFromDB(1);\\
	user.age = 31;
	await updateUserInDB(user);
};
</code></pre></div></div>

<ul>
  <li>동일한 시간에 사용자 B도 자신의 정보를 수정하려고 한다</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const updateUserB = async () =&gt; {
	const user = await getUIserFromDB(1);
	user.age = 32;
	await updateUserInDB(user);
</code></pre></div></div>

<p>→ 충돌 발생</p>

<ul>
  <li>사용자 a와 사용자 b는 동시에 데이터베이스에서 동일한 사용자 정보를 가져와 수정하고 저장하려고 한다. 데이터베이스에는 사용자 a와 b가 동시에 업데이트를 시도하므로 충돌이 발생한다</li>
  <li>충돌이 발생한 후 , 데이터베이스에서 최정적으로 저장된 사용자 정보를 마지막으로 업데이트해서 반영한다</li>
</ul>

<h2 id="충돌이-해결되는-과정">충돌이 해결되는 과정</h2>

<ol>
  <li>데이터베이스 업데이트</li>
</ol>

<ul>
  <li>사용자 A와 사용자 B가 동시에 데이터베이스의 사용자 정보를 가져오고 수정합니다.</li>
  <li>각각의 업데이트는 데이터베이스 트랜젝션 내에서 처리된다</li>
</ul>

<ol>
  <li>데이터베이스 충돌 감지</li>
</ol>

<ul>
  <li>데이터베이스는 사용자 A와 사용자 B의 업데이트가 동시에 실행되어 충돌이 발생했음을 감지한다</li>
</ul>

<ol>
  <li>충돌 해결</li>
</ol>

<ul>
  <li>충돌 해결에는 두가지 방법이 있다.
    <ul>
      <li>비관적 잠금 (Pessimistic Locking) : 사용자 A가 데이터를 가져올 때 데이터베이스에서 해당 데이터를 잠그고, 사용자 B는 데이터를 가져오는 동안 기다려야 한다. 이후 사용자 A와 B중 먼저 업데이트를 시도한 사용자의 변경 내용이 반영된다</li>
      <li>낙관적 잠금(Optimistic Locking) : 사용자 A와 B가 데이터를 가져온 후 업데이트를 시도한다. 데이터베이스에서는 A와 B애가 가져온 데이터의 버전을 비교한다. 만약 버전이 동일하다면 업데이트를 허용하고 , 버전이 다르다면 충돌이 감지되었다고 알린다. 이후 A와 B에게 충돌을 해결하라고 선택권을 주거나, 나중에 다시 시도하도록 유도한다</li>
    </ul>
  </li>
</ul>

<ol>
  <li>최종 업데이트</li>
</ol>

<ul>
  <li>충돌이 해결되고 데이터베이스에서 사용자 A와 B의 업데이트를 모두 반영한 후 , 최종 사용자 정보가 데이터베이스에 저장된다</li>
  <li>이때, 마지막으로 업데이트한 사용자의 변경 내용이 반영되므로, 최종 나이가 32인 경우에는 사용자 B의 업데이트가 마지막으로 반영된 경우이다.</li>
</ul>

<ol>
  <li>응답 및 결과</li>
</ol>

<ul>
  <li>데이터베이스가 최종 업데이트를 수행한 후 , 사용자 A와 B에게 각각의 요청에 대한 응답을 반환합니다</li>
  <li>응답은 수정 후의 최종 결과를 나타내며, 데이터베이스에서 저장된 최신 상태를 반영한다</li>
</ul>

<p>이렇게 충돌이 발생하고 해결되면 최종적으로 데이터베이스에 반영된 결과를 사용자 A와 B에게 반환하여 제공된다. 충돌이 발생할 경우 충돌 해결 전까지 어느 한 사용자의 업데이트가 최종 반영되지 않은 것이다</p>

<h2 id="오늘-하루-리뷰">오늘 하루 리뷰 </h2>

<p>오늘 몸이 너무 안따라준다. 헤롱헤롱한다. 너무 아프다. 진짜 두통이 너무 심하다. 글자를 읽을 때마다 울렁거린다. 약간 속도 메스껍고 토할 것 같다. 잠이 너무 온다. 죽을 것 같다 진짜. 속도 안좋다. 잠도 많이 온다. 어제부터 죽을 것 같아서 몬스터 흰색 캔을 2개를 땄다. 어쩌겠니… 돈벌어야 하는데…</p>

<p>몸이 너무 아프다. 잠이 너무 많아진다. 이러다가 진짜 죽는건 아닐지 하고 아픈데 열은 또 안 난다. 춥고 덥다. 근데 또 갑자기 미친듯이 먹고싶을때가 있다. 또 밥먹기 싫을때는 미친듯이 먹기 싫다.</p>

<p>이게 무슨 일이람… 내과 가서 물어봐야 하나,,,</p>

<p>글자 보면 울렁거려서 못참겠다니깐.</p>

<p>그래도 해야지 어떡해…그래도 해야지 어떡해.</p>

<p>독감이 괜히 독감이 아닌가봐…독해서 독감이야</p>]]></content><author><name>insidepixce</name></author><category term="all" /><category term="react" /><summary type="html"><![CDATA[독감은 독해서 독감이구나]]></summary></entry><entry><title type="html">암호화 키 오류</title><link href="/react/all/2024/01/12/itsone.html" rel="alternate" type="text/html" title="암호화 키 오류" /><published>2024-01-12T12:00:00+09:00</published><updated>2024-01-12T12:00:00+09:00</updated><id>/react/all/2024/01/12/itsone</id><content type="html" xml:base="/react/all/2024/01/12/itsone.html"><![CDATA[<p>아침부터 에러나는건 우리 예의가 아니지 </p>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/7kap/image/X7sAg-E45Tgfn5DhO46R2O1wN3Q.jpg" alt="예시 이미지" /></p>

<p>리엑트 네이티브로 개발하는 앱에서 결제 기능을 추가하는 것은 꽤나 일반적인 작업 중 하나인데 오늘 진짜 특이한 경험을 했다.</p>

<p>하지마 이 개새끼야 ~!!!!!</p>

<h2 id="1-문제-발견">1. 문제 발견</h2>

<p>결제 프로세스를 시작하자 마자 “암호화 키가 일치하지 않는다”라는 에러가 발생했다. 테스트해보니 사용자에게도 노출될 코드였다.</p>

<h2 id="2-초기분석">2. 초기분석</h2>

<p>처음에는서버측에서 보내는 암호화 키와 클라이언트에서사용하는 암호화 키가 다르다고 생각했다. 서버 코드를 열고 관련 키 값들을 점검했다. 근데,,, 어,,, 둘다 암호화 키가 같다…?</p>

<h2 id="3-디버깅-시작">3. 디버깅 시작</h2>

<p>결제과정 코드를 꼼꼼히 살펴보았다. 하는 도중에 내가 이래서 js를 좋아한다는 걸 깨달았다. 읽기가 너무 편해</p>

<p>아무튼 암호화 모듈을 살펴보았는데, 네이티브 모듈로 구현되어있었다. js코드와 네이티브 코드간의 통신이 피요했다</p>

<h2 id="4-문제의-원인을-봤다">4. 문제의 원인을 봤다.</h2>

<p>암호화를 담당하는 부분의 로직을 보고 보고 보고 또 봤다. 아니 세상에. 암호화 키를 생성하고 저장하는 로직에 큰 문제점이 있었다. 암호화 키는 앱이 설치될때마다 생성되어야 하는데 이 키가 여러번 생성되어서 중복되는 문제가 있었다. 서버에서는 암호화된 데이터를 복호화할수 없었고, 이러한 문제가 생겨버린 것이다.</p>

<p>실제 코드는 아니지만 재현해보자면 이런 구조였다</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { NativeModules } from 'react-native';

const { EncryptionModule } = NativeModules;

class PaymentService {
  constructor() {
    this.encryptionKey = this.generateEncryptionKey();
  }

  generateEncryptionKey() {
    return EncryptionModule.generateKey();
  }

  makePayment(data) {
    const encryptedData = EncryptionModule.encrypt(data, this.encryptionKey);
    // ... 결제 로직
  }
}
</code></pre></div></div>

<p>‘PaymentService’클래스가 생성될때마다 ‘generateEncryptionKey’함수가 호출되어 암호화 키가 생성된다. 다른 모듈이나 컴포넌트에서 ‘PaymentService’를 여러번 초기화할 경우, 다양한 키 값들이 생성되었고, 그게 문제였던 것이다 !</p>

<p>ㅇ아ㅏ… 이마 한 번 짚고 다시 달린다.</p>

<ol>
  <li>키 생성 로직 개선 : 암호화 키 생성 로직을 수정해 키가 한번만 생성되도록 만든다</li>
  <li>데이터베이스 키 저장 : 생성된 키를 로컬 데이터베이스에 저장하고 앱이 실행될때마다 해당 키를 불러와 사용하도록 로직을 바꿨다.</li>
  <li>키 동기화 : 서버와의 통신 시 생성된 키를 함께 전송하여 서버도 동일한 키를 사용하도록 했다.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import { NativeModules } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';

const { EncryptionModule } = NativeModules;

class PaymentService {
  constructor() {
    this.loadEncryptionKey();
  }

  async loadEncryptionKey() {
    let key = await AsyncStorage.getItem('encryptionKey');
    if (!key) {
      key = EncryptionModule.generateKey();
      await AsyncStorage.setItem('encryptionKey', key);
    }
    this.encryptionKey = key;
  }

  makePayment(data) {
    const encryptedData = EncryptionModule.encrypt(data, this.encryptionKey);
    // ... 결제 로직
  }
}
</code></pre></div></div>

<p>대충 이런 구조로 수정해주었다</p>

<ul>
  <li>Singleton Pattern : ‘PaymentService’를 싱글톤 패턴으로 구현하여 인스턴스가 하나만 생성되도록하였다. 이렇게 하면 암호화 키도 한 번만 생성된다</li>
  <li>AsyncStorage : 생성된 암호화 키를 로컬에 저장하여 앱이 재시작될때마다 동일한 키를 사용하도록 했다. 이를 위해 @react-native-async-storage/async-storage 라이브러리를 사용했다</li>
  <li>초기화 로직 변경 : ‘PaymentService’의 초기화 로직에서 암호화 키를 생성하는 대신, 로컬 데이터베이스에서 불러와 사용하도록 변경해주었다. 키가 없을 경우에만 새로 생성했다.</li>
  <li>아마도 로컬로 저장하는것도 방법인 것 같다. 생성된 암호화 키는 로컬 데이터베이스, 예를 들면 AsyncStorage</li>
</ul>

<p>암호화는 데이터 보호를 위해 꼭 필요한 과정이다. 특히 결제나 인증과 같은 중요한 트랜젝션에서는 데이터의 무결성을 보장하기 위해 암호화가 필수이다. 리엑트 네이티브에서도 이러한 암호하 처리가 필요하고, 암호화 키를 안전하게 관리하는 것 또한 중요한데,  진짜 나 정신차리자 .</p>]]></content><author><name>insidepixce</name></author><category term="all" /><category term="react" /><summary type="html"><![CDATA[아침부터 에러나는건 우리 예의가 아니지 ]]></summary></entry><entry><title type="html">multer</title><link href="/node.js/all/2024/01/12/multer.html" rel="alternate" type="text/html" title="multer" /><published>2024-01-12T12:00:00+09:00</published><updated>2024-01-12T12:00:00+09:00</updated><id>/node.js/all/2024/01/12/multer</id><content type="html" xml:base="/node.js/all/2024/01/12/multer.html"><![CDATA[<p>뮬터</p>

<h2 id="multer-모듈">Multer 모듈</h2>

<p>Multer는 Node.js 환경에서 파일 업로드를 처리하기 위한 미들웨어이다. Express와 함께 사용하면 파일 업로드를 쉽게 처리할 수 있으며, connect-multiparty와 비교하여 더 유연하고 안정적으로 파일 업로드를 처리할 수 있다.</p>

<p>Multer는 다양한 옵션을 제공하여 파일 업로드를 보다 세밀하게 제어할 수 있으며, 다양한 예외 상황에 대한 처리도 가능하다.</p>

<p>예를 들어, 파일 사이즈 제한, 파일 형식 제한, 파일 이름 중복 방지 등 다양한 옵션을 설정할 수 있다. 또한, Multer는 여러 파일을 동시에 업로드할 수 있으며, 업로드된 파일의 정보를 쉽게 가져올 수 있는 API도 제공한다.</p>

<p>Multer 모듈은 다음과 같이 설치할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install multer

</code></pre></div></div>

<p>Multer를 사용하기 위해서는 먼저 multer 모듈을 임포트해야 한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const multer = require('multer');

</code></pre></div></div>

<ol>
  <li>multer 모듈을 임포트한다.</li>
  <li>multer 객체를 생성한다. 이때, storage, limits, fileFilter 등의 옵션을 설정할 수 있다.</li>
  <li>multer 객체를 사용하여 파일 업로드를 처리한다. 이때, single, array, fields 등의 메소드를 사용하여 파일 업로드를 처리할 수 있다.</li>
</ol>

<h3 id="파일-업로드-처리">파일 업로드 처리</h3>

<p>multer는 http 요청의 본문에 포함된 파일을 서버로 업로드할 수 있도록 지원함</p>

<p>upload.single(fieldname) 또는 upload.array(fieldname[, maxCount])과 같은 메서드를 사용하여 단일 파일 또는 여러 파일을 처리할 수 있음</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const multer = require('multer');
const upload = multer({ dest: 'uploads/' });

app.post('/profile', upload.single('ramona'), (req, res, next) =&gt; {
  // req.file은 `ramona` 파일에 대한 정보
  // 키(`avatar`)는 multer 미들웨어가 사용되는 필드
})

</code></pre></div></div>

<ul>
  <li>multer는 HTTP 요청의 본문에 포함된 파일을 서버로 업로드할 수 있도록 지원한다</li>
  <li>upload.single(fieldname) 또는 upload.array(fieldname[, maxCount])과 같은 메서드를 사용하여 단일 파일 또는 여러 파일을 처리할 수 있다</li>
  <li>upload.single(fieldname)은 fieldname 필드의 단일 파일을 처리한다</li>
  <li>req.file 객체는 파일에 대한 정보를 담고 있다. fieldname은 upload.single() 메서드가 사용되는 필드 이름</li>
</ul>

<h3 id="파일-저장-경로-및-이름-지정">파일 저장 경로 및 이름 지정</h3>

<p>업로드된 파일의 저장 경로와 이름을 지정할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const multer = require('multer');
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, 'uploads/')
  },
  filename: function (req, file, cb) {
    cb(null, file.fieldname + '-' + Date.now())
  }
});
const upload = multer({ storage: storage });

</code></pre></div></div>

<ul>
  <li>storage 옵션을 설정해 파일 저장 위치, 파일 이름 규칙, 파일 확장자 등을 제어할 수 있다.</li>
  <li>multer.diskStorage() 메서드를 사용하여 파일 저장 경로와 파일 이름 규칙을 설정한다.</li>
  <li>cb 콜백 함수를 사용하여 저장 경로와 파일 이름을 반환한다.</li>
  <li>cb(null, ‘uploads/’)는 업로드된 파일이 uploads 폴더에 저장되도록 지정한다.</li>
  <li>cb(null, file.fieldname + ‘-‘ + Date.now())는 파일 이름을 fieldname-현재시간 형식으로 지정</li>
</ul>

<h3 id="파일-유효성-검사">파일 유효성 검사</h3>

<p>filefilter 옵션을 설정하여 허용되는 파일 확장자, 파일 크기 등을 제한할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const multer = require('multer');
const upload = multer({
  storage: storage,
  fileFilter: function (req, file, cb) {
    // 파일 필터링 로직
    if (!file.originalname.match(/\\\\\\\\.(jpg|jpeg|png|gif)$/)) {
      return cb(new Error('Only image files are allowed!'));
    }
    cb(null, true);
  }
});

</code></pre></div></div>

<ul>
  <li>fileFilter 옵션을 설정해 허용되는 파일 확장자, 파일 크기 등을 제한할 수 있다.</li>
  <li>fileFilter 콜백 함수는 업로드할 파일의 유효성을 검사한다.</li>
  <li>파일이 유효한 경우 cb(null, true)를 호출한다.</li>
  <li>유효하지 않은 경우 cb(new Error(‘Only image files are allowed!’))와 같이 에러를 반환한다</li>
</ul>

<h3 id="여러-필드-처리">여러 필드 처리</h3>

<p>단일 파일 뿐만 아니라 여러 필드(텍스트, 파일)등을 동시에 처리할 수 있다</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const multer = require('multer');
const upload = multer();

app.post('/profile', upload.fields([
  { name: 'avatar', maxCount: 1 },
  { name: 'gallery', maxCount: 8 }
]), (req, res, next) =&gt; {
  // req.files는 `avatar`와 `gallery` 파일에 대한 정보
  // 키(`avatar`와 `gallery`)는 multer 미들웨어가 사용되는 필드명
})
</code></pre></div></div>

<ul>
  <li>단일 파일 뿐만 아니라 여러 필드(텍스트, 파일)등을 동시에 처리할 수 있다.</li>
  <li>upload.fields(fields) 메서드를 사용하여 여러 필드를 처리한다.</li>
  <li>fields는 배열 형태로 필드 정보를 담고 있다</li>
  <li>필드 정보는 { name: 필드이름, maxCount: 파일 수 }의 형태로 지정한다.</li>
  <li>req.files 객체에는 { 필드이름: 파일정보 } 형태로 정보가 담겨 있다.</li>
</ul>]]></content><author><name>insidepixce</name></author><category term="all" /><category term="react" /><summary type="html"><![CDATA[뮬터]]></summary></entry><entry><title type="html">데이터 타입은 모르겠고 오류를 안 띄우려면</title><link href="/c/s/all/2024/01/12/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-copy.html" rel="alternate" type="text/html" title="데이터 타입은 모르겠고 오류를 안 띄우려면" /><published>2024-01-12T12:00:00+09:00</published><updated>2024-01-12T12:00:00+09:00</updated><id>/c/s/all/2024/01/12/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0%20copy</id><content type="html" xml:base="/c/s/all/2024/01/12/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-copy.html"><![CDATA[<p>​<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F7sekW%2Fbtsp3nRnHPg%2Fkls8pGQkvvgixWP3o19DsK%2Fimg.png" alt="썸네일" /></p>
<blockquote>
  <p>이 글은 <모던 자바스크립트="" 딥="" 다이브=""> 라는 책을 읽고 필자가 재구성하여 작성한 글입니다.</모던></p>
</blockquote>

<h1 id="데이터-타입의-필요성">데이터 타입의 필요성</h1>

<p>데이터 타입은 왜 필요한 것인가?</p>

<h2 id="️--데이터-타입에-의한-메모리-공간-확보와-참조를-위해">🙋‍♀️ : 데이터 타입에 의한 메모리 공간 확보와 참조를 위해</h2>

<p>값은 메모리에 저장하고 참조할 수 있어야 한다. 메모리에 값을 저장하려면 먼저 확보해야 할 메모리의 크기를 결정해야 한다.</p>

<p><img src="https://velog.velcdn.com/images/insidepixce/post/94364519-4048-4e4a-9eab-25152f4593e0/image.png" alt="" /></p>

<p>이렇게 숫자 타입 값이 할당된다.</p>

<blockquote>
  <p>자바스크립트는 숫자 타입의 값을 생성할 때 배정밀도 64비트 부동소수점 형식을 사용한다. 따라서 실제로 메모리에 저장되는 2진수 값은 위 그림과 다른다. 지금은 간단히 양의 정수로 저장된다고 생각하자</p>
</blockquote>

<p>→ 64비트 부동소수점 형식에 관해서는 이전에 다뤄보았다.</p>

<h3 id="--값을-생성할-때-명확한-기준이-없어-조금-헷갈리는걸">🤔 : 값을 생성할 때? 명확한 기준이 없어 조금 헷갈리는걸??</h3>

<p>→ 값을 생성할 때란 무엇인가???</p>

<p>프로그램이 실행되는 동안 변수에 할당되거나, 연산이 이루어지거나, 함수가 실행되면서 새로운 값을 만든다는 것을 의미</p>

<p>→ 변수를 선언하고 값을 할당하는 경우</p>

<p>→ 연산을 수행하는 경우</p>

<p>→ 함수를 실행하는 경우</p>

<p>즉 “자바스크립트에서 값을 생성한다” 는 것은 프로그램이 동작하면서 새로운 값을 만들고 변수에 저장하거나 결과로 반환하는 행위를 말한다.</p>

<h2 id="--자바스크립트에서-참조한다는-것은">🤷 : 자바스크립트에서 참조한다는 것은?</h2>

<ul>
  <li>변경이 가능한 값의 의미이다</li>
  <li>객체를 가리키는 변수를 다른 변tn 에 할당하면 원본의 참조 값이 복사되어 전달된다.</li>
</ul>

<p>자바스크립트에서 참조(Reference)는 변수가 객체나 배열과 같은 데이터 구조에 대한 메모리 주소를 가리키는 것을 의미한다. 다른 말로 하면, 참조는 실제 데이터가 위치한 메모리 영역에 직접 접근하는 것이 아니라, 데이터가 위치한 주소를 통해 해당 데이터에 접근하는 방법을 제공한다.</p>

<p>객체를 선언하여 생성한다</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const originalObject = {name : "insidepixce", age : 20};
</code></pre></div></div>

<p>변수 object가 originalObject를 가리킨다</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const referenceObject = originalObject;
</code></pre></div></div>

<p>referenceObject를 통해 Originalobject의 속성에 접근하고 수정한다</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>referenceObject.age = 21;
</code></pre></div></div>

<p>이때 originalObject와 referenceObject는 같은 객체를 가리키고 있다. 따라서 ‘referenceObject’를 통해 해당 객체의 속성을 수정하면 Original Object속의 속성도 같이 변경된다. 이는 객체의 데이터가 복사되지 않고 메모리 주소를 공유하기 떄문이다.</p>

<ul>
  <li>참조는 배열에서도 마찬가지로 동작한다</li>
</ul>

<p>즉, 식별자를 통해 메모리 공간의 주소를 찾아가는 것이다. 이때 값을 참조하려면 한번에 메모리를 몇 개를 읽어들여야 할지, 즉 메모리 셀의 개수(바이트 수)를 알아야 한다.</p>

<h3 id="--그럼-식별자-컴퓨터는-한-번에-읽어-들여야-할-메모리-셀의-크기를-어떻게-알-수-있는가">🙄 : 그럼 식별자 컴퓨터는 한 번에 읽어 들여야 할 메모리 셀의 크기를 어떻게 알 수 있는가?</h3>

<p><strong>🙆‍♀️ : 심벌 테이블이요!</strong></p>

<blockquote>
  <p>컴파일러 또는 인터프리터는 심벌 테이블이라고 부르는 자료 구조를 통해 식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리한다.</p>
</blockquote>

<p><strong>🤦‍♂️ : 그래서 심벌 테이블이 뭐냐고?</strong></p>

<p>컴파일러와 인터프리터 등의 프로그래밍 언어 처리 시스템에서 식별자를 관리하는 자료구조.</p>

<p>심벌 테이블은 각 식별자에 대해 이름과 해당 식별자가 사용되는 메모리 주소 또는 다른 정보를 매핑한다.</p>

<p>인터프리터는 식별자를 사용할 때 해당 식별자가 선언되었는지, 어떤 타입인지, 어느 범위에서 유효한지 등을 파악해야 한다. 이러한 정보는 실행 중인 프로그램에서 변수나 함수를 사용할 때 식별자가 가리키는 정확한 메모리 주소를 알고 있어야 하기 때문이다.</p>

<p><strong><em>심벌 테이블</em></strong>은 이러한 정보를 저장하고 유지 관리하는 역할을 한다. 컴파일러 또는 인터프리터는 소스코드를 분석하면서 식별자를 발견하면 해당 식별자와 관련된 정보를 심벌 테이블에 추가하거나 참조한다.</p>

<p>→ 일반적으로 해시 테이블 또는 기타 효율적인 데이터 구조를 사용하여 구현됨</p>

<p>→ 언어마다 다름</p>

<p>🌈 <strong><em>그래서 요약하자면!</em></strong></p>

<blockquote>
  <p>프로그래밍 언어 처리 시스템에서 식별자를 관리하고, 해당 식별자의 정보를 저장하고 유지 관리하는 자료구조. 이를 통해 변수와 함수 등의 식별자를 정확하게 해석하고 프로그램을 올바르게 처리할 수 있다.</p>
</blockquote>

<h1 id="-동적-타입-언어와-정적-타입-언어">🌷 동적 타입 언어와 정적 타입 언어</h1>

<p>자바스크립트의 모든 값은 데이터 값을 가진다.</p>

<blockquote>
  <p>🤔 : 그렇다면 변수는 데이터 타입을 가질까?</p>
</blockquote>

<p>정적 타입 언어는 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있음</p>

<p>→ 컴파일 시점에 <strong>타입체크</strong> 진행</p>

<p>→ 선언한 데이터 타입에 맞는 값을 할당했는지 보는 검사임</p>

<p>→ 이 검사 통과 못하면 실행 자체를 막음</p>

<p>타입의 일관성을 강제함으로서 더욱 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄인다</p>

<p>c, c++, 자바, 코틀린, 고, 하스켈, 러스트 , 스칼라 등등…</p>

<p>동적 타입 언어는 변수의 타입을 변경할 수 있으며, 변수에 할당된 값의 타입에 따라 실행 시점에 타입이 결정된다.</p>

<p>→ 변수의 타입을 설정하지 않고 값을 할당할 수 있음</p>

<p>→ 실행 도중에 변수의 타입이 자주 변경될 수 있음</p>

<p>→ 이로 인해 버그 발생 가능성이 높아짐</p>

<p>정적 타입 언어와 달리, 실행 시점에 타입이 결정되므로 타입 에러가 발생하기 쉽다. 따라서 개발자는 변수의 타입을 주의깊게 관리하고, 코드를 작성할 때 타입 에러를 방지할 수 있는 방법을 찾아야 한다.</p>

<blockquote>
  <p>typeof 연산자는 연산자 뒤에 위치한 피연산자의 데이터 타입을 문자열로 반환한다</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var foo;
console.log (typeof foo);

foo = 3;
console.log (typeof foo);
</code></pre></div></div>

<p>이런식으로 실행할 수 있다.</p>

<p>💡 변수의 데이터 타입을 반환하는 것이 아니라 변수에 할당된 값의 데이터 타입을 반환한다.</p>

<p>자바스크립트의 변수에는 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있다</p>

<p>→ 값을 할당하는 시점에 변수의 타입이 동적으로 결정뙤고 변수의 타입을 언제든지 자유롭게 변경할 수 있다</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>💯  자바스립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론) 되며,
재할당에 의해 변수의  타입은 언제든지 동적으로 변할 수 있다.
</code></pre></div></div>

<p>이러한 특징을 동적 타이핑이라고 하며, 자바스크립트를 정적 타입 언어와 구별짓기 위해 동적 타입 언어라고 한다. 대표적인 동적 타입 언어로는 자바스크립트, 파이썬, PHP, 루비, 리스프 , 펄 등이 있다.</p>

<p>이쯤 되어 아까 했던 질문으로 돌아가 보자</p>

<blockquote>
  <p>🤔 : 그렇다면 변수는 데이터 타입을 가질까?</p>
</blockquote>

<p>→ 기본적으로 변수는 타입을 갖지 않는다. 하지만 값은 타입을 갖는다.</p>

<p>따라서 현재 변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정된다고 표현하는 것이 더 적절하다.</p>

<p>변수는 값에 묶여 있는 값에 대한 별명이기 때문이다.</p>

<h1 id="-동적-타입-언어와-정적-타입-언어-1">🌷 동적 타입 언어와 정적 타입 언어</h1>

<p>동적 타입 언어는 변수에 어떤 값이라도 자유롭게 할당할 수 있다.</p>

<p>자바스크립트를 사용하다 보면 따로 변수 할당을 안 해줘도 원하는 타입으로 사용할 수 있기 때문에 이는 데이터 타입에 무감각해질 정도로 편리해진다.</p>

<p>그렇지만 편리함에 이면에는 위험도 있다.</p>

<blockquote>
  <p><strong>모든 소프트웨어 아키텍쳐에는 트레이드오프가 존재하며, 모든 애플리케이션에 적합한 은 탄환은 없듯이 동적 타입 언어 또한 구조적인 단점이 있다</strong></p>
</blockquote>

<p><em>Trade-off = 두 개의 정책이나 목표 중 하나를 달성하고자 하면 다른 목표의 달성이 늦어지거나 희생되는 모순적 관계를 의미함.</em></p>

<p><em>은 탄환: 아마 고질적인 문제를 단번에 해결할 수 있는 명쾌한 해결책…정도를 의미한듯</em></p>

<p>변수 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있다. 변수의 타입이 고정되어 있지 않고 동적으로 변한다.</p>

<p>→ 동적 타입 언어의 변수는 값의 변경에 의해 타입도 언제든지 변경될 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  💯 따라서 **동적 타입 언어의 변수는 값을 확인하기 전**에는 타입을 확신할 수 없다.
</code></pre></div></div>

<p>개발자의 의도와는 상관없어 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 한다.</p>

<p>잘못된 예측에 의해 오류를 뿜어내는 프로그램을 본다면… 🤦‍♀️</p>

<p>결국 동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다</p>

<h2 id="️-안정적인-프로그램을-만들고-싶어요">🙋‍♀️ 안정적인 프로그램을 만들고 싶어요!</h2>

<ul>
  <li>변수는 꼭 필요한 경우에 한해 제한적으로 사용한다</li>
  <li>변수의 유효 범위는 최대한 좁게 만들어 변수의 부작용을 억제해야 한다</li>
  <li>전역 변수는 최대한 사용하지 않도록 한다</li>
  <li>변수보다는 상수를 사용해 값의 변경을 억제한다</li>
  <li>변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다.</li>
</ul>

<p>사실 변수 오류는 그닥 많이 겪어보지 않았다. 내가 초보 개발자이며 아직 경험이 많이 없어서 그런지는 모른다. 하지만 책을 공부하다가 한번쯤은 정리해놓고 싶은 부분이라 작성해보았다.</p>]]></content><author><name>insidepixce</name></author><category term="all" /><category term="react" /><summary type="html"><![CDATA[​ 이 글은 라는 책을 읽고 필자가 재구성하여 작성한 글입니다.]]></summary></entry><entry><title type="html">동기비동기 한판정리</title><link href="/c/s/all/2024/01/12/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0.html" rel="alternate" type="text/html" title="동기비동기 한판정리" /><published>2024-01-12T12:00:00+09:00</published><updated>2024-01-12T12:00:00+09:00</updated><id>/c/s/all/2024/01/12/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0</id><content type="html" xml:base="/c/s/all/2024/01/12/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0.html"><![CDATA[<p>​<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FA6ni2%2Fbtsk1CjTRcs%2FQqlCB2OrK7jhEF8wpWKjTk%2Fimg.jpg" alt="썸네일" /></p>
<h2 id="동기비동기-정리">동기/비동기 정리</h2>

<p>동기/비동기는 자바스크립트에서 중요한 개념 중 하나이다. 동기는 코드가 순차적으로 실행된다는 것을 의미하며, 비동기는 코드가 순차적으로 실행되지 않는다는 것을 의미한다. 비동기 코드는 예측할 수 없는 순서로 실행되며, 실행이 완료되면 콜백 함수가 호출된다.</p>

<p>동기 코드의 예시는 다음과 같다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function add(x, y) {
  return x + y;
}

const result = add(1, 2);
console.log(result); // 3

</code></pre></div></div>

<p>위 코드에서 add 함수는 두 개의 숫자를 더한 값을 반환하는 일반적인 함수이다. 함수가 호출되면 결과가 즉시 반환되며, 결과는 result 변수에 할당된다. 이것은 동기 코드이다.</p>

<p>비동기 코드의 예시는 다음과 같다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setTimeout(() =&gt; {
  console.log('Hello, World!');
}, 1000);

</code></pre></div></div>

<p>위 코드에서 setTimeout 함수는 일정 시간이 지난 후에 실행될 콜백 함수를 등록하는 함수이다. 이 함수는 1초 후에 ‘Hello, World!’ 문자열을 콘솔에 출력한다. 이것은 비동기 코드이다. setTimeout 함수가 호출되면 결과가 즉시 반환되지 않으며, 1초 후에 콜백 함수가 호출된다.</p>

<p>따라서 자바스크립트에서는 비동기 함수를 항상 콜백 함수와 함께 사용해야 한다. 이를 통해 비동기 코드의 실행 순서를 보장하고, 비동기 함수가 완료된 후에 콜백 함수를 호출할 수 있다.</p>

<h2 id="예시">예시</h2>

<p>동기와 비동기를 이해하기 위해 일상 생활에서의 예시를 들어볼 수 있다.</p>

<p>예를 들어, 음식을 주문하는 것을 생각해보자. 동기 방식에서는 주문을 하면 음식이 나올 때까지 대기하며, 결과가 반환될 때까지 다른 일을 할 수 없다. 반면, 비동기 방식에서는 주문을 하고 나면 다른 스케줄을 세우거나, 다른 주문을 하거나, 롤이나 한 판 하는 등 다른 작업을 할 수 있다. 음식이 나오면 알림을 받아서 음식을 수령하고 먹으면 된다.</p>

<p>이와 같이 동기 방식은 결과가 반환될 때까지 대기해야 하며, 다른 작업을 수행할 수 없다. 반면, 비동기 방식은 결과가 반환되기를 기다리지 않고 다른 작업을 수행할 수 있다.</p>

<h1 id="예시-1">예시</h1>
<ul>
  <li>
    <h3 id="-시나리오-1-">[ 시나리오 1 ]</h3>
  </li>
  <li>개발팀장이 3명의 사원에게 동시다발적으로 각각의 업무를 지시한다. ( = 비동기 )</li>
  <li>놀랍게도 개발팀장은 3명의 사원에게 시킨 일을 확인도 안하고 본인 할 일도 한다 ( = 비동기 )</li>
  <li>
    <p>사원마다 맡은 일을 알아서 끝내고 개발팀장에게 보고한다. ( = 논블로킹 )</p>
  </li>
  <li>
    <h3 id="-시나리오-2-">[ 시나리오 2 ]</h3>
  </li>
  <li>개발팀장이 사원1 에게 업무를 지시한다.</li>
  <li>그리고 사원1 업무가 끝날때까지 언제 끝나냐고 눈초리를 준다. ( = 동기 )</li>
  <li>사원1 의 업무처리가 너무 느려서 다른 사원에게 일을 주려고한다. ( = 비동기 )</li>
  <li>그런데 사원1 은 도와달라며 개발팀장의 옷자락을 붙잡는다. ( = 블로킹 )</li>
  <li>그걸 지켜보는 사원2 와 사원3 은 무슨 일을 주던 열심히 할 생각은 있지만 일이 없다. ( = 동기 )</li>
</ul>

<h2 id="요약">요약</h2>

<p>동기/비동기 프로그래밍은 모든 프로그래밍 언어에서 중요한 개념 중 하나이다. 동기 프로그래밍은 코드가 순차적으로 실행되며, 결과가 즉시 반환된다는 것을 의미한다. 비동기 프로그래밍은 코드가 순차적으로 실행되지 않으며, 결과가 바로 반환되지 않는다는 것을 의미한다.</p>

<p>비동기 함수는 대개 비동기 콜백 함수와 함께 사용되며, 콜백 함수는 비동기 함수가 완료된 후에 호출된다. 이를 통해 프로그램이 예측 가능한 방식으로 실행되는 것을 보장할 수 있다. 예를 들어, 파일을 읽는 비동기 함수는 파일이 성공적으로 읽혔을 때 콜백 함수를 호출하여 결과를 반환한다.</p>

<p>동기 함수와 비동기 함수는 각각의 장단점이 있으며, 상황에 따라 적절한 방식을 선택해야 한다. 일반적으로, 네트워크 요청과 같은 오래 걸리는 작업을 수행할 때는 비동기 함수를 사용하는 것이 좋다. 이를 통해 사용자 인터페이스가 응답성을 유지하면서 백그라운드 작업이 수행될 수 있다.</p>

<h1 id="이해가-안-갈-까봐-예시를-더-만들어봤습니다">이해가 안 갈 까봐 예시를 더 만들어봤습니다</h1>

<h2 id="예시-1-커피-주문하기">예시 1: 커피 주문하기</h2>

<h3 id="동기적인-상황">동기적인 상황:</h3>
<p>고객이 커피 주문을 하면, 커피를 만드는 동안 다른 주문은 받지 않는다
주문이 완료되고 커피가 나오면, 그 다음 주문을 받는다</p>

<h3 id="비동기적인-상황">비동기적인 상황:</h3>
<p>고객이 커피 주문을 하면, 주문은 바로 받아들이고 고객에게 예상 소요 시간을 알려준다 
커피가 만들어지는 동안에도 다른 주문을 받아줄 수 있다
각 주문이 완료되면, 그때마다 손님에게 알림을 주고 커피를 준다.</p>

<p>동기적인 프로그래밍은 한 작업이 끝나야 다음 작업이 시작되는 반면, 비동기적인 프로그래밍은 여러 작업이 동시에 진행될 수 있고, 완료된 순서대로 결과를 얻을 수 있다는 것을 이해해야만 한다. 이러한 특성은 주로 네트워크 요청, 파일 다운로드, 사용자 인터랙션 등의 상황에서 뚜렷하게 나타난다.</p>]]></content><author><name>insidepixce</name></author><category term="all" /><category term="react" /><summary type="html"><![CDATA[​ 동기/비동기 정리]]></summary></entry><entry><title type="html">변수로 시작해 스와핑기법까지</title><link href="/c/s/all/2024/01/12/%EB%B3%80%EC%88%98%EC%97%90%EC%84%9C%EC%8A%A4%EC%99%80%ED%95%91.html" rel="alternate" type="text/html" title="변수로 시작해 스와핑기법까지" /><published>2024-01-12T12:00:00+09:00</published><updated>2024-01-12T12:00:00+09:00</updated><id>/c/s/all/2024/01/12/%EB%B3%80%EC%88%98%EC%97%90%EC%84%9C%EC%8A%A4%EC%99%80%ED%95%91</id><content type="html" xml:base="/c/s/all/2024/01/12/%EB%B3%80%EC%88%98%EC%97%90%EC%84%9C%EC%8A%A4%EC%99%80%ED%95%91.html"><![CDATA[<p>변수,,변수</p>

<h1 id="변수란-무엇인가">💁🏻 변수란 무엇인가</h1>
<p>우리가 10+20을 하면 10과 20, 그리고 + 를 기억하여 그 결과를 계산한다.</p>

<p>→ 이는 컴퓨터도 마찬가지이다.</p>

<p>→ 10은 리터럴 + 는 연산자이다. 이들을 모두 알아서 해석한다.</p>

<p>그럼 10과 20은 어디에 저장하는가? 이들은 모두 메모리에 저장된다.</p>

<p>각 메모리에는 메모리 주소가 있다</p>

<p>→ 이 숫자들은 모두 이진으로 저장된다.</p>

<p>메모리 주소에 저장된 이 친구들을 불러내야 하는데, 직접 메모리 주소를 사용하면 위험도가 있다.</p>

<p>→ 메모리 주소에 직접 접근하다가 시스템의 메모리에 잘못 접근하면 엄청난 문제가 생길 수 있기 때문이다.</p>

<p>⇒ 그래서 자바스크립트는 메모리 주소에 직접적으로 접근하지 못한다.</p>

<p>🤔 그렇다면 우리는 한 개의 값으로 연산을 할 때마다 그 값을 새로 입력해줘야 하는 것인가?</p>

<h3 id="그래서-변수라는-개념이-나온-것이다-">😃 그래서 변수라는 개념이 나온 것이다 !</h3>

<p>내가 만약 10이라는 값을 <strong>할당</strong> 한다고 하자</p>

<p>💡 할당이란 값을 변수에 넣는 것이다</p>

<p>이때 10은 고유한 메모리에 들어갈 것이다</p>

<p>이때 각 메모리 주소를 전부 입력할 수 없으니 (접근이 제한되어 있으니) 우리는 메모리 주소에 이름을 붙인다. 이를 변수라고 한다.</p>

<hr />

<h1 id="그렇다면-질문이-있는데">🤔그렇다면 질문이 있는데…</h1>

<h2 id="️변수와-물리적-주소-가상-주소까지-공부의-시작이였던-이-질문">🤷🏻‍♂️변수와 물리적 주소 가상 주소까지… 공부의 시작이였던 이 질문</h2>

<p>👩🏻‍💼: A라는 변수에 10이라는 값을 할당하는 프로그램을 작성하고 프로그램을 실행 후 완전히 종료하고 다시 실행했다. 그렇다면 10이라 값은 다시 한 번 다른 메모리 자리에 할당되고 이 변수의 이름이 A가 되는 것인가?</p>

<p>그렇다면 이전에 할당된 메모리는 쓰지 않을 텐데, 어떻게 관리하는 것인가?</p>

<p>⏹  : 프로그램을 실행하면 컴퓨터는 해당 프로그램을 메모리에 로드하고 실행하는데, 이 과정에서 변수와 데이터는 메모리에 할당된다.</p>

<p>변수 A에 10이라는 값을 할당하는 경우, 10이라는 데이터가 메모리에 저장되고 해당 메모리 위치에 변수 이름인 A가 매핑된다.</p>

<p>프로그램을 실행하고 완전히 종료한 후 다시 실행하면, 기본적으로 운영체제는 새로운 프로세스로 실행을 시작한다. 이전 실행에서 사용된 메모리는 더이상 사용하지 않는다.</p>

<h2 id="️이-메모리는-어떻게-처리하냐라고-묻는다면">🤷🏻‍♂️이 메모리는 어떻게 처리하냐라고 묻는다면…?</h2>

<p>운영체제는 프로세스의 실행과 종료를 관리하고 각 프로세스가 필요로 하는 메모리를 할당하고 회수하는 작업이 수행된다.</p>

<p>프로그램이 종료되면 해당 프로세스에 사용된 메모리는 운영체제에 의해 회수되어 재사용 가능한 상태가 된다. 이렇게 함으로써 메모리 사용을 좀 더 효율적으로 관리하고 충돌이나 <strong>메모리 누수</strong>와 같은 문제를 방지한다.</p>

<h1 id="메모리-누수란">메모리 누수란?</h1>

<p>💡 메모리 누수란? : 응용 프로그램에서 데이터를 메모리에 저장했다가, 필요없어졌을때 적절하게 제거되지 않는 것. ‘메모리 릭 (Memory leak)이라고도 한다</p>

<ul>
  <li>메모리에 데이터가 남아 있어도 운영 체제가 의도한 것이라면 데이터 누수가 아니다</li>
  <li>windows vista 이후의 운영체제 및 안드로이드에선 옛날만큼 메모리 공간이 빡빡하지 않다는 것을 감안하여 종료시킨 프로그램을 일부러 메모리 상에 남겨두기도 한다</li>
</ul>

<p>→ 사용자가 다시 실행시켰을때 더 빠르게 응답할 수 있다.</p>

<p>→ 사용자가 다른 작업을 하다가 다시 메모리가 부족해지면 알아서 정리해준다.</p>

<p>??? 엥? 저번에 들었던 가비지 컬렉션의 개념이 생각나. 그 개념은 언어 자체가 메모리를 관리하는 거였는데??</p>

<h2 id="운영-체제의-메모리를-관리-vs-가비지-컬렉션">운영 체제의 메모리를 관리 VS 가비지 컬렉션</h2>

<h3 id="운영-체제가-메모리를-관리하는-것">🌐 운영 체제가 메모리를 관리하는 것</h3>

<ul>
  <li>운영 체제는 프로세스가 메모리를 요청하면 해당 메모리를 할당하고 , 프로세스가 종료되면 메모리를 회수하여 재사용 가능한 상태로 만든다</li>
  <li>프로세스들 간의 메모리 공간을 분리하여 충돌이나 오류를 방지하고, 시스템의 안정성을 유지한다</li>
</ul>

<h3 id="가비지-컬렉션">🗑 가비지 컬렉션</h3>

<ul>
  <li>프로그래밍 언어의 <strong>런타임 환경</strong>에서 담당하는 기능으로, 메모리를 동적으로 관리하는 상황에서 발생하는 메모리 누수를 방지하고 자동으로 더 이상 사용되지 않는 메모리를 회수하는 역할을 함</li>
  <li>더이상 필요없는 변수, 객체들을 식별하고 메모리를 자동으로 회수하여 재사용 가능한 상태로 만들어준다.</li>
  <li>JAVA, C#, PYTHON 등의 언어에서 가비지 컬렉션을 지원하며 언어의 런타임 환경이 가비지 컬렉션을 담당한다</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>운영 체제는 컴퓨터 자원을 관리함
프로세스들의 실행과 메모리 할당/ 회수 담당

가비지 컬렉션은 런타임에서 메모리 관리를 담당
사용하지 않는 것을 식별하고 자동으로 회수
</code></pre></div></div>

<p>사실 아직도 그 둘의 차이를 잘 이해를 못 했었다.</p>

<p>그래서 예시를 들어서 공부해보기로 했다</p>

<h1 id="이렇게-가정해보자">💡 이렇게 가정해보자</h1>

<ol>
  <li>VS CODE를 실행한다</li>
  <li>A = 10이라는 값을 할당하는 코드를 쓴다</li>
  <li>코드를 실행한다</li>
  <li>종료한다</li>
  <li>VS CODE를 닫는다</li>
</ol>

<ul>
  <li>VS CODE를 실행한다</li>
</ul>

<p>→ 운영 체제는 VScode 프로세스에 필요한 메모리를 할당하고, 사용할 수 있도록 확보한다.</p>

<h2 id="-이때-좀-더-자세한-과정을-보자면">😺 : 이때 좀 더 자세한 과정을 보자면…</h2>

<p>→ 가상 주소와 물리 주소에 대한 설명은 이 과정을 모두 적고 공부해보았다.</p>

<h3 id="1-프로세스-생성">1. 프로세스 생성</h3>

<ul>
  <li>VSCODE를 실행하면 운영 체제는 새로운 프로세스를 생성한다.</li>
  <li>프로세스는 실행 중인 프로그램을 나타내며, 자신만의 독립된 메모리 공간을 가지고 실행한다</li>
</ul>

<h3 id="2-가상-주소-공간-할당">2. 가상 주소 공간 할당</h3>

<ul>
  <li>운영 체제는 VS CODE 프로세스에게 <strong>가상 주소 공간</strong>을 할당한다. 가상 주소 공간은 각 프로세스가 독립적으로 사용하는 가상의 메모리 공간을 의미한다.</li>
  <li>이 가상 주소 공간은 실제 물리적 메모리와는 분리되어 있으며, 프로세스가 사용하는 주소들은 <strong>가상 주소</strong>로 매핑되어 실제 메모리에 할당된다.</li>
</ul>

<h3 id="3-물리적-메모리-할당">3. 물리적 메모리 할당</h3>

<ul>
  <li>가상 주소 공간에 할당된 메모리는 실제 물리적 메모리에 매핑되어야 한다.</li>
  <li>이때 운영 체제는 VSCODE 프로세스가 필요로 하는 물리적 메모리를 확보한다.</li>
  <li>즉 , 운영 체제는 VSCODE에 필요한 메모리 공간을 실제 물리적 메모리에 할당하여 사용할 수 있도록 한다.</li>
</ul>

<h3 id="4-메모리-보호">4. 메모리 보호</h3>

<ul>
  <li>운영 체제는 각 프로세스들간의 메모리 공간을 보호하기 위해 메모리 보호 기법을 사용한다.</li>
  <li>각 프로세스는 자신의 주소 공간에서만 접근이 가능하고, 다른 프로세스의 주소 공간에는 접근할 수 없도록 제한된다.</li>
</ul>

<h3 id="5-프로세스-실행">5. 프로세스 실행</h3>

<ul>
  <li>VSCODE 프로세스가 메모리를 할당받고 초기화되면, 운영 체제는 해당 프로세스를 실행시킨다.</li>
  <li>이제 VSCODE는 자신의 가상 주소 공간 내에서 실행되며, 필요한 데이터와 코드가 메모리에 로드되어 사용된다</li>
</ul>

<h3 id="7-변수-쓰기-가비지-컬렉션">7. 변수 쓰기 (가비지 컬렉션)</h3>

<ul>
  <li>자바스크립트의 경우</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// main.js
let A = 10;
console.log(A);
</code></pre></div></div>

<p>변수 A에 10이 할당되고, 콘솔에 10이 출력된다. 코드 실행이 완료되면 NODE.JS가 사용한 메모리는 운영 체제에 의 해 회수된다.</p>

<p>JS는 가비지 컬렉션을 내장해 이때 가비지 컬렉터에 의해 식별되고 자동으로 회수된다.</p>

<ul>
  <li>C언어의 경우</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;

int main() {
    int A = 10;
    printf("%d\n", A);
    return 0;
}
</code></pre></div></div>

<p>코드 실행이 완료되면 C프로그램이 사용한 메모리는 운영 체제에 의해 회수된다. C 언어는 메모리 할당과 해제를 개발자가 직접 관리해야 하므로, 메모리 누수가 발생하지 않도록 메모리 해제 코드를 작성해야 한다</p>

<h3 id="8-프로세스-종료">8. 프로세스 종료:</h3>

<ul>
  <li>VSCODE 실행이 끝나고 VSCODE를 종료하면, 운영 체제는 해당 프로세스가 사용한 메모리를 회수한다.</li>
  <li>프로세스가 종료되면 할당된 가상 주소 공간과 물리적 메모리는 다른 프로세스가 사용할 수 있도록 해제된다.</li>
  <li>이렇게 함으로써 VSCODE의 실행에 사용된 메모리가 운영 체제에 의해 회수되고 재사용 가능한 상태가 된다</li>
</ul>

<h1 id="가상-주소란-무엇인가">💁🏻  <strong>가상 주소</strong> 란 무엇인가?</h1>

<p>가상 메모리란? 프로세스는 가상 주소를 사용하고, 데이터를 사용할때 물리 주소로 변환해준다는 것이다.</p>

<p>가상 주소 : 프로세스가 참조하는 주소</p>

<p>물리 주소 : 실제 메모리 주</p>

<p>MMU : CPU에 코드 실행시, 가상 주소 메모리 접근이 필요할때, 해당 주소를 물리 주소 값으로 변환시켜주는 하드웨어 장치.</p>

<h2 id="그럼-가상-주소-왜-쓰는데">🤓 그럼 가상 주소 왜 쓰는데?</h2>

<ol>
  <li>프로세스 독립성 : 각 프로세스는 각각의 가상 주소 공간을가지고 있다. 이로 인해 프로세스는 서로의 주소 공간에 영향을 미치지 않고 독립적으로 실행될 수 있다.</li>
</ol>

<p>→ 따라서 하나의 프로세스에서 발생한 오류나 메모리 접근 오류가 다른 포르세스에 영향을 미치지 않아 안정성이 향상된다</p>

<h2 id="️여기서-발생한-의문">🤷🏻‍♂️ 여기서 발생한 의문!</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🤔그냥 물리적인 주소를 각각 다르게 주면 되는 거 아니야?
</code></pre></div></div>

<p>→ 가상 주소는 논리적인 주소이다.</p>

<p>→ 가상 주소를 사용하면 여러 프로세스들이 메모리를 공유할 수 있다. 물리적 메모리의 용량보다 더 많은 가상 주소를 가진 프로세스들이 동시에 실행될 수 있으며, 가상 주소를 물리적 주소로 매핑함으로써 메모리를 효율적으로 사용할 수 있다.</p>

<p>🤬 이게 뭔 소리냐?</p>

<p>아니, 가상 주소는 프로세스가 각각의 가상 주소 공간을 가지며 서로의 공간에 영향을 미치지 않고 독립적으로 사용할 수 있게 한다고 했잖아… 그런데 메모리를 공유한다는 건 무슨 소리야 도대체?</p>

<h2 id="그럼-한번-예시를-들어보자">📤 그럼 한번 예시를 들어보자</h2>

<p>프로세스 A와 B가 있다. 이들은 물리적 메모리의 용량보다 크다. 이때 가상 주소로 해결하는 방법을 알아보자.</p>

<p>→ 가상 주소를 사용하여 메모리를 효율적으로 관리하기 위해서 운영 체제는 물리적 메모리를 효율적으로 활용해야 한다.</p>

<h3 id="1-가상-주소-공간-할당">1. 가상 주소 공간 할당:</h3>

<p>운영 체제는 각 프로세스 A와 B에게 가상 주소 공간을 할당한다.</p>

<p>각 프로세스는 <strong>자신만의</strong> 가상 주소 공간을 갖게 된다</p>

<h3 id="2-물리적-메모리-공간-관리-">2. 물리적 메모리 공간 관리 :</h3>

<p>물리적 메모리에는 실제 데이터와 프로그램 코드가 저장되므로 모든 가상 주소를 물리적 주소로 직접 할당할 수는 없다.</p>

<h3 id="3-페이지-기반-가상-메모리-관리">3. 페이지 기반 가상 메모리 관리:</h3>

<p>대부분의 운영 체제는 페이지 기반의 가상 메모리 관리를 사용하여 가상 주소와 물리적 주소 간의 매핑을 수행한다. 가상 메모리를 작은 크기의 페이지로 나누고, 물리적 메모리도 동일한 크기의 페이지로 나눈다.</p>

<h3 id="4-페이지-테이블">4. 페이지 테이블:</h3>

<p>각 프로세스마다 페이지 테이블이라는 자료구조를 유지한다.</p>

<ul>
  <li><strong>페이지 테이블이란</strong> 페이지 테이블은 가상 주소의 각 페이지가 실제 물리적 메모리의 어떤 페이지와 매핑되는지를 기록한다. 프로세스가 가상 주소를 참조하면 페이지 테이블을 사용하여 해당 가상 주소를 물리적 주소로 변환한다
    <ul>
      <li>페이지 번호(Page Number): 가상 주소에서 페이지 번호를 식별하는 부분</li>
      <li>페이지 프레임 번호(Page Frame Number): 물리적 메모리에서 페이지가 위치하는 프레임 번호를 기록</li>
      <li>기타 제어 비트(Control Bits): 페이지에 대한 다양한 제어 정보를 포함한다 예를 들어 해당 페이지가 물리적 메모리에 들어가졌었는지의 여부, 수정 가능한 페이지인지 등을 나타낼 수 있따.</li>
    </ul>
  </li>
</ul>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlKzlK%2Fbtsp6pVGHt4%2FXQMomZiZhorHEcz72zslb1%2Fimg.png" alt="이미지" /></p>

<p>가상 주소에 의해 주소가 지정된 페이지와 물리 메모리의 페이지 간의 관계 (단순한 주소 공간 스킴에서) 물리 메모리는 수많은 프로세스에 속하는 페이지를 포함할 수 있다. 거의 사용하지 않을 경우 페이지는 디스크에 보관할 수 있으며, 물리 메모리가 꽉차 있으면 위의 그림처럼 일부 페이지는 물리 메모리에 위치하지 않는다.</p>

<p>(이미지 출처: 위키백과)</p>

<h3 id="5-페이지-폴트">5. 페이지 폴트</h3>

<p>프로세스가 처음으로 해당 페이지를 접근할 때 물리적 메모리에 해당 페이지가 없는 경우 페이지 폴트가 발생</p>

<ul>
  <li>페이지 폴트란? → 즉, 프로세스가 요청한 페이지가 현재 물리적 메모리에 올라와 있지 않을 때 발생 → 이 경우 운영체제는 해당 페이지를 물리적 메모리로 가져와야 함
    <ul>
      <li>프로세스가 페이지 폴트를 발생시키면, 운영 체제는 먼저 해당 페이지가 디스크에 저장되어 있는지 확인한다</li>
      <li>만약 해당 페이지가 디스크에 저장되어 있다면, 디스크에서 가져온다</li>
      <li>가져온 페이지를 물리적 메모리에 적재하고, 페이지 테이블을 업데이트하여 해당 가상 주소가 새로운 물리적 주소와 매핑되도록 한다</li>
      <li>이후에 다시 참조해보면 데이터나 코드에 접근할 수 있다</li>
    </ul>
  </li>
</ul>

<h3 id="6-페이지-교체">6. 페이지 교체</h3>

<p>물리적 메모리 공간이 가득 찬 경우, 운영 체제는 페이지 교체 알고리즘을 사용하여 더 이상 사용되지 않는 페이지를 디스크로 옮기고 새로운 페이지를 메모리에 로드한다.</p>

<p>→ 이렇게 함으로써 물리적 메모리에 가상 주소 공간을 연결할 수 있다</p>

<h3 id="7-다중-프로그래밍과-스와핑">7. 다중 프로그래밍과 스와핑</h3>

<p>다중 프로그래밍 환경에서는 여러 개의 프로세스가 동시에 실행된다. 만약 모든 프로세스가 동시에 물리적 메모리에 올라갈 수 없는 경우, 운영 체제는 스와핑 기법을 사용하여 현재 실행 중인 프로세스의 일부를 디스크로 내보내고, 새로운 프로세스를 메모리에 로드함으로써 다른 프로세스로 전환한다.</p>

<hr />

<h1 id="후기">후기</h1>

<p>변수가 어디에 할당되는지 찾다가 많은 것을 알게 된 공부였다.<br />
실제 메모리보다 더 쓰는 방식으로 저러한 방식을 채택한 개발자들이 정말 대단해 보였고 나 또한 저렇게 시대를 이끌어가는 개발자가 되고 싶었다.</p>]]></content><author><name>insidepixce</name></author><category term="all" /><category term="react" /><summary type="html"><![CDATA[변수,,변수]]></summary></entry></feed>